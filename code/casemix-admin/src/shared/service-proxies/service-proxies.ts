//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isTenantAvailable(body: IsTenantAvailableInput | undefined): Observable<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsTenantAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsTenantAvailable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IsTenantAvailableOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IsTenantAvailableOutput>;
        }));
    }

    protected processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IsTenantAvailableOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IsTenantAvailableOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: RegisterInput | undefined): Observable<RegisterOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegisterOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegisterOutput>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<RegisterOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegisterOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterOutput>(null as any);
    }
}

@Injectable()
export class BodyStructureGroupsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<BodyStructureGroupDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BodyStructureGroups/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BodyStructureGroupDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BodyStructureGroupDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<BodyStructureGroupDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BodyStructureGroupDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BodyStructureGroupDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllWithSubProcedures(): Observable<BodyStructureGroupDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BodyStructureGroups/GetAllWithSubProcedures";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWithSubProcedures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWithSubProcedures(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BodyStructureGroupDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BodyStructureGroupDto[]>;
        }));
    }

    protected processGetAllWithSubProcedures(response: HttpResponseBase): Observable<BodyStructureGroupDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BodyStructureGroupDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BodyStructureGroupDto[]>(null as any);
    }

    /**
     * @param hospitalId (optional) 
     * @return Success
     */
    getByHospital(hospitalId: string | null | undefined): Observable<BodyStructureGroupDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BodyStructureGroups/GetByHospital?";
        if (hospitalId !== undefined && hospitalId !== null)
            url_ += "hospitalId=" + encodeURIComponent("" + hospitalId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByHospital(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByHospital(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BodyStructureGroupDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BodyStructureGroupDto[]>;
        }));
    }

    protected processGetByHospital(response: HttpResponseBase): Observable<BodyStructureGroupDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BodyStructureGroupDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BodyStructureGroupDto[]>(null as any);
    }

    /**
     * @param surgeonId (optional) 
     * @return Success
     */
    getBySurgeon(surgeonId: number | undefined): Observable<BodyStructureGroupDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BodyStructureGroups/GetBySurgeon?";
        if (surgeonId === null)
            throw new Error("The parameter 'surgeonId' cannot be null.");
        else if (surgeonId !== undefined)
            url_ += "surgeonId=" + encodeURIComponent("" + surgeonId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBySurgeon(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBySurgeon(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BodyStructureGroupDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BodyStructureGroupDto[]>;
        }));
    }

    protected processGetBySurgeon(response: HttpResponseBase): Observable<BodyStructureGroupDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BodyStructureGroupDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BodyStructureGroupDto[]>(null as any);
    }

    /**
     * @param bodyStructureGroupId (optional) 
     * @return Success
     */
    getByBodyStructureGroupId(bodyStructureGroupId: string | null | undefined): Observable<BodyStructureGroupDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BodyStructureGroups/GetByBodyStructureGroupId?";
        if (bodyStructureGroupId !== undefined && bodyStructureGroupId !== null)
            url_ += "bodyStructureGroupId=" + encodeURIComponent("" + bodyStructureGroupId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByBodyStructureGroupId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByBodyStructureGroupId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BodyStructureGroupDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BodyStructureGroupDto[]>;
        }));
    }

    protected processGetByBodyStructureGroupId(response: HttpResponseBase): Observable<BodyStructureGroupDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BodyStructureGroupDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BodyStructureGroupDto[]>(null as any);
    }

    /**
     * @param hospitalId (optional) 
     * @return Success
     */
    getAllBodyStructureGroupByUsers(hospitalId: string | null | undefined): Observable<BodyStructureGroupDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BodyStructureGroups/GetAllBodyStructureGroupByUsers?";
        if (hospitalId !== undefined && hospitalId !== null)
            url_ += "hospitalId=" + encodeURIComponent("" + hospitalId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBodyStructureGroupByUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBodyStructureGroupByUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BodyStructureGroupDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BodyStructureGroupDto[]>;
        }));
    }

    protected processGetAllBodyStructureGroupByUsers(response: HttpResponseBase): Observable<BodyStructureGroupDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BodyStructureGroupDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BodyStructureGroupDto[]>(null as any);
    }

    /**
     * @param hospitalId (optional) 
     * @return Success
     */
    getHospitalSpecialty(hospitalId: string | null | undefined): Observable<SpecialtyInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BodyStructureGroups/GetHospitalSpecialty?";
        if (hospitalId !== undefined && hospitalId !== null)
            url_ += "hospitalId=" + encodeURIComponent("" + hospitalId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHospitalSpecialty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHospitalSpecialty(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SpecialtyInfoDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SpecialtyInfoDto[]>;
        }));
    }

    protected processGetHospitalSpecialty(response: HttpResponseBase): Observable<SpecialtyInfoDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SpecialtyInfoDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SpecialtyInfoDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveHospitalSpecialties(body: SpecialtyInfoDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BodyStructureGroups/SaveHospitalSpecialties";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveHospitalSpecialties(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveHospitalSpecialties(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveHospitalSpecialties(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class BodyStructureProceduresServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<BodyStructureSubProcedureDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BodyStructureProcedures/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BodyStructureSubProcedureDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BodyStructureSubProcedureDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<BodyStructureSubProcedureDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BodyStructureSubProcedureDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BodyStructureSubProcedureDto[]>(null as any);
    }
}

@Injectable()
export class BodyStructuresServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<BodyStructureDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BodyStructures/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BodyStructureDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BodyStructureDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<BodyStructureDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BodyStructureDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BodyStructureDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getMethods(): Observable<ProcedureMethodDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BodyStructures/GetMethods";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMethods(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMethods(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProcedureMethodDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProcedureMethodDto[]>;
        }));
    }

    protected processGetMethods(response: HttpResponseBase): Observable<ProcedureMethodDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ProcedureMethodDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProcedureMethodDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMenu(id: number | undefined): Observable<MenuItemOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BodyStructures/GetMenu?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMenu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMenu(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MenuItemOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MenuItemOutputDto[]>;
        }));
    }

    protected processGetMenu(response: HttpResponseBase): Observable<MenuItemOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(MenuItemOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MenuItemOutputDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    refreshMenuCache(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BodyStructures/RefreshMenuCache?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefreshMenuCache(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefreshMenuCache(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRefreshMenuCache(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    clearMenuCache(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BodyStructures/ClearMenuCache";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearMenuCache(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearMenuCache(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processClearMenuCache(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class CoMorbiditiesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<CoMorbidityGroupDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CoMorbidities/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CoMorbidityGroupDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CoMorbidityGroupDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<CoMorbidityGroupDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CoMorbidityGroupDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CoMorbidityGroupDto[]>(null as any);
    }
}

@Injectable()
export class ConfigurationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeUiTheme(body: ChangeUiThemeInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Configuration/ChangeUiTheme";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeUiTheme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeUiTheme(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangeUiTheme(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class CountriesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param all (optional) 
     * @return Success
     */
    getAll(all: boolean | null | undefined): Observable<CountryDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Countries/GetAll?";
        if (all !== undefined && all !== null)
            url_ += "all=" + encodeURIComponent("" + all) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CountryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CountryDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<CountryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CountryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CountryDto[]>(null as any);
    }
}

@Injectable()
export class DeviceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param deviceId (optional) 
     * @param stat (optional) 
     * @return Success
     */
    enableDisableDevice(deviceId: number | undefined, stat: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Device/EnableDisableDevice?";
        if (deviceId === null)
            throw new Error("The parameter 'deviceId' cannot be null.");
        else if (deviceId !== undefined)
            url_ += "deviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (stat === null)
            throw new Error("The parameter 'stat' cannot be null.");
        else if (stat !== undefined)
            url_ += "stat=" + encodeURIComponent("" + stat) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnableDisableDevice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnableDisableDevice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processEnableDisableDevice(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @param stat (optional) 
     * @param hospitalId (optional) 
     * @param body (optional) 
     * @return Success
     */
    devicesAvailability(stat: number | undefined, hospitalId: string | null | undefined, body: number[] | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Device/DevicesAvailability?";
        if (stat === null)
            throw new Error("The parameter 'stat' cannot be null.");
        else if (stat !== undefined)
            url_ += "stat=" + encodeURIComponent("" + stat) + "&";
        if (hospitalId !== undefined && hospitalId !== null)
            url_ += "hospitalId=" + encodeURIComponent("" + hospitalId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDevicesAvailability(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDevicesAvailability(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDevicesAvailability(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @param stat (optional) 
     * @param body (optional) 
     * @return Success
     */
    enableDisableSelected(stat: number | undefined, body: number[] | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Device/EnableDisableSelected?";
        if (stat === null)
            throw new Error("The parameter 'stat' cannot be null.");
        else if (stat !== undefined)
            url_ += "stat=" + encodeURIComponent("" + stat) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnableDisableSelected(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnableDisableSelected(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processEnableDisableSelected(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @return Success
     */
    getAllDeviceClass(): Observable<DeviceClassDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Device/GetAllDeviceClass";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDeviceClass(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDeviceClass(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DeviceClassDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DeviceClassDto[]>;
        }));
    }

    protected processGetAllDeviceClass(response: HttpResponseBase): Observable<DeviceClassDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DeviceClassDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceClassDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getByDeviceId(id: number | undefined): Observable<DeviceDto> {
        let url_ = this.baseUrl + "/api/services/app/Device/GetByDeviceId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByDeviceId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByDeviceId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DeviceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DeviceDto>;
        }));
    }

    protected processGetByDeviceId(response: HttpResponseBase): Observable<DeviceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeviceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceDto>(null as any);
    }

    /**
     * @param gmdntermCode (optional) 
     * @return Success
     */
    getByDeviceGMDNCode(gmdntermCode: string | null | undefined): Observable<DevicesTermCodeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Device/GetByDeviceGMDNCode?";
        if (gmdntermCode !== undefined && gmdntermCode !== null)
            url_ += "gmdntermCode=" + encodeURIComponent("" + gmdntermCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByDeviceGMDNCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByDeviceGMDNCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DevicesTermCodeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DevicesTermCodeDto[]>;
        }));
    }

    protected processGetByDeviceGMDNCode(response: HttpResponseBase): Observable<DevicesTermCodeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DevicesTermCodeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DevicesTermCodeDto[]>(null as any);
    }

    /**
     * @param gmdntermCode (optional) 
     * @return Success
     */
    getByDeviceCode(gmdntermCode: string | null | undefined): Observable<DevicesTermCodeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Device/GetByDeviceCode?";
        if (gmdntermCode !== undefined && gmdntermCode !== null)
            url_ += "gmdntermCode=" + encodeURIComponent("" + gmdntermCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByDeviceCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByDeviceCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DevicesTermCodeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DevicesTermCodeDto[]>;
        }));
    }

    protected processGetByDeviceCode(response: HttpResponseBase): Observable<DevicesTermCodeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DevicesTermCodeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DevicesTermCodeDto[]>(null as any);
    }

    /**
     * @param documentId (optional) 
     * @param manufacturerId (optional) 
     * @param bodyStructureGroupId (optional) 
     * @param deviceClassId (optional) 
     * @param deviceFamilyId (optional) 
     * @param file (optional) 
     * @return Success
     */
    uploadFile(documentId: number | null | undefined, manufacturerId: string | null | undefined, bodyStructureGroupId: string | null | undefined, deviceClassId: string | null | undefined, deviceFamilyId: number | null | undefined, file: FileParameter | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Device/UploadFile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (documentId !== null && documentId !== undefined)
            content_.append("DocumentId", documentId.toString());
        if (manufacturerId !== null && manufacturerId !== undefined)
            content_.append("ManufacturerId", manufacturerId.toString());
        if (bodyStructureGroupId !== null && bodyStructureGroupId !== undefined)
            content_.append("BodyStructureGroupId", bodyStructureGroupId.toString());
        if (deviceClassId !== null && deviceClassId !== undefined)
            content_.append("DeviceClassId", deviceClassId.toString());
        if (deviceFamilyId !== null && deviceFamilyId !== undefined)
            content_.append("DeviceFamilyId", deviceFamilyId.toString());
        if (file !== null && file !== undefined)
            content_.append("File", file.data, file.fileName ? file.fileName : "File");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUploadFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getBodyStructureGroups(): Observable<BodyStructureGroupDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Device/GetBodyStructureGroups";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBodyStructureGroups(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBodyStructureGroups(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BodyStructureGroupDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BodyStructureGroupDto[]>;
        }));
    }

    protected processGetBodyStructureGroups(response: HttpResponseBase): Observable<BodyStructureGroupDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BodyStructureGroupDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BodyStructureGroupDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getManufacturers(): Observable<ManufactureDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Device/GetManufacturers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManufacturers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManufacturers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ManufactureDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ManufactureDto[]>;
        }));
    }

    protected processGetManufacturers(response: HttpResponseBase): Observable<ManufactureDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ManufactureDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ManufactureDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getDeviceClass(): Observable<DeviceClassDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Device/GetDeviceClass";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceClass(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceClass(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DeviceClassDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DeviceClassDto[]>;
        }));
    }

    protected processGetDeviceClass(response: HttpResponseBase): Observable<DeviceClassDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DeviceClassDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceClassDto[]>(null as any);
    }

    /**
     * @param bodyStructureGroupId (optional) 
     * @return Success
     */
    getAllDeviceFamily(bodyStructureGroupId: string | undefined): Observable<DeviceFamilyDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Device/GetAllDeviceFamily?";
        if (bodyStructureGroupId === null)
            throw new Error("The parameter 'bodyStructureGroupId' cannot be null.");
        else if (bodyStructureGroupId !== undefined)
            url_ += "bodyStructureGroupId=" + encodeURIComponent("" + bodyStructureGroupId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDeviceFamily(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDeviceFamily(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DeviceFamilyDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DeviceFamilyDto[]>;
        }));
    }

    protected processGetAllDeviceFamily(response: HttpResponseBase): Observable<DeviceFamilyDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DeviceFamilyDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceFamilyDto[]>(null as any);
    }

    /**
     * @param bodyStructureGroupId (optional) 
     * @param deviceFamilyId (optional) 
     * @param deviceClassId (optional) 
     * @return Success
     */
    generateDeviceCSVTemplate(bodyStructureGroupId: string | undefined, deviceFamilyId: number | undefined, deviceClassId: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Device/GenerateDeviceCSVTemplate?";
        if (bodyStructureGroupId === null)
            throw new Error("The parameter 'bodyStructureGroupId' cannot be null.");
        else if (bodyStructureGroupId !== undefined)
            url_ += "bodyStructureGroupId=" + encodeURIComponent("" + bodyStructureGroupId) + "&";
        if (deviceFamilyId === null)
            throw new Error("The parameter 'deviceFamilyId' cannot be null.");
        else if (deviceFamilyId !== undefined)
            url_ += "deviceFamilyId=" + encodeURIComponent("" + deviceFamilyId) + "&";
        if (deviceClassId === null)
            throw new Error("The parameter 'deviceClassId' cannot be null.");
        else if (deviceClassId !== undefined)
            url_ += "deviceClassId=" + encodeURIComponent("" + deviceClassId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateDeviceCSVTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateDeviceCSVTemplate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGenerateDeviceCSVTemplate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<DeviceDto> {
        let url_ = this.baseUrl + "/api/services/app/Device/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DeviceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DeviceDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<DeviceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeviceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceDto>(null as any);
    }

    /**
     * @param manufacturerId (optional) 
     * @param bodyStructureGroupId (optional) 
     * @param deviceClassId (optional) 
     * @param hospitalId (optional) 
     * @param disabledOnly (optional) 
     * @param unAvailableOnly (optional) 
     * @param keyword (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(manufacturerId: string | null | undefined, bodyStructureGroupId: string | null | undefined, deviceClassId: string | null | undefined, hospitalId: string | null | undefined, disabledOnly: boolean | undefined, unAvailableOnly: boolean | undefined, keyword: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<DeviceDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Device/GetAll?";
        if (manufacturerId !== undefined && manufacturerId !== null)
            url_ += "ManufacturerId=" + encodeURIComponent("" + manufacturerId) + "&";
        if (bodyStructureGroupId !== undefined && bodyStructureGroupId !== null)
            url_ += "BodyStructureGroupId=" + encodeURIComponent("" + bodyStructureGroupId) + "&";
        if (deviceClassId !== undefined && deviceClassId !== null)
            url_ += "DeviceClassId=" + encodeURIComponent("" + deviceClassId) + "&";
        if (hospitalId !== undefined && hospitalId !== null)
            url_ += "hospitalId=" + encodeURIComponent("" + hospitalId) + "&";
        if (disabledOnly === null)
            throw new Error("The parameter 'disabledOnly' cannot be null.");
        else if (disabledOnly !== undefined)
            url_ += "DisabledOnly=" + encodeURIComponent("" + disabledOnly) + "&";
        if (unAvailableOnly === null)
            throw new Error("The parameter 'unAvailableOnly' cannot be null.");
        else if (unAvailableOnly !== undefined)
            url_ += "UnAvailableOnly=" + encodeURIComponent("" + unAvailableOnly) + "&";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DeviceDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DeviceDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<DeviceDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeviceDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: DeviceDto | undefined): Observable<DeviceDto> {
        let url_ = this.baseUrl + "/api/services/app/Device/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DeviceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DeviceDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<DeviceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeviceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: DeviceDto | undefined): Observable<DeviceDto> {
        let url_ = this.baseUrl + "/api/services/app/Device/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DeviceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DeviceDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<DeviceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeviceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Device/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class DeviceProcedureServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param deviceId (optional) 
     * @param hospitalId (optional) 
     * @return Success
     */
    getByDeviceId(deviceId: number | undefined, hospitalId: string | null | undefined): Observable<BodyStructureGroupDto[]> {
        let url_ = this.baseUrl + "/api/services/app/DeviceProcedure/GetByDeviceId?";
        if (deviceId === null)
            throw new Error("The parameter 'deviceId' cannot be null.");
        else if (deviceId !== undefined)
            url_ += "deviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (hospitalId !== undefined && hospitalId !== null)
            url_ += "hospitalId=" + encodeURIComponent("" + hospitalId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByDeviceId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByDeviceId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BodyStructureGroupDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BodyStructureGroupDto[]>;
        }));
    }

    protected processGetByDeviceId(response: HttpResponseBase): Observable<BodyStructureGroupDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BodyStructureGroupDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BodyStructureGroupDto[]>(null as any);
    }

    /**
     * @param deviceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    saveSelectedDeviceProcedures(deviceId: number | undefined, body: TreeNodeInput[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DeviceProcedure/SaveSelectedDeviceProcedures?";
        if (deviceId === null)
            throw new Error("The parameter 'deviceId' cannot be null.");
        else if (deviceId !== undefined)
            url_ += "deviceId=" + encodeURIComponent("" + deviceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveSelectedDeviceProcedures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveSelectedDeviceProcedures(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveSelectedDeviceProcedures(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @param bodyStructureId (optional) 
     * @param hospitalId (optional) 
     * @param brandName (optional) 
     * @param deviceFamilyId (optional) 
     * @param model (optional) 
     * @return Success
     */
    getBySnomedId(id: string | null | undefined, bodyStructureId: number | undefined, hospitalId: string | null | undefined, brandName: string | null | undefined, deviceFamilyId: number | undefined, model: string | null | undefined): Observable<DeviceDto[]> {
        let url_ = this.baseUrl + "/api/services/app/DeviceProcedure/GetBySnomedId?";
        if (id !== undefined && id !== null)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (bodyStructureId === null)
            throw new Error("The parameter 'bodyStructureId' cannot be null.");
        else if (bodyStructureId !== undefined)
            url_ += "bodyStructureId=" + encodeURIComponent("" + bodyStructureId) + "&";
        if (hospitalId !== undefined && hospitalId !== null)
            url_ += "hospitalId=" + encodeURIComponent("" + hospitalId) + "&";
        if (brandName !== undefined && brandName !== null)
            url_ += "brandName=" + encodeURIComponent("" + brandName) + "&";
        if (deviceFamilyId === null)
            throw new Error("The parameter 'deviceFamilyId' cannot be null.");
        else if (deviceFamilyId !== undefined)
            url_ += "deviceFamilyId=" + encodeURIComponent("" + deviceFamilyId) + "&";
        if (model !== undefined && model !== null)
            url_ += "model=" + encodeURIComponent("" + model) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBySnomedId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBySnomedId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DeviceDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DeviceDto[]>;
        }));
    }

    protected processGetBySnomedId(response: HttpResponseBase): Observable<DeviceDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DeviceDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @param bodyStructureId (optional) 
     * @param hospitalId (optional) 
     * @param bodyStructureGroupId (optional) 
     * @param isFilterLicensedStatus (optional) 
     * @return Success
     */
    getBySnomedIdGrouped(id: string | null | undefined, bodyStructureId: number | undefined, hospitalId: string | null | undefined, bodyStructureGroupId: string | null | undefined, isFilterLicensedStatus: boolean | undefined): Observable<DeviceBrandFamilyViewDto> {
        let url_ = this.baseUrl + "/api/services/app/DeviceProcedure/GetBySnomedIdGrouped?";
        if (id !== undefined && id !== null)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (bodyStructureId === null)
            throw new Error("The parameter 'bodyStructureId' cannot be null.");
        else if (bodyStructureId !== undefined)
            url_ += "bodyStructureId=" + encodeURIComponent("" + bodyStructureId) + "&";
        if (hospitalId !== undefined && hospitalId !== null)
            url_ += "hospitalId=" + encodeURIComponent("" + hospitalId) + "&";
        if (bodyStructureGroupId !== undefined && bodyStructureGroupId !== null)
            url_ += "bodyStructureGroupId=" + encodeURIComponent("" + bodyStructureGroupId) + "&";
        if (isFilterLicensedStatus === null)
            throw new Error("The parameter 'isFilterLicensedStatus' cannot be null.");
        else if (isFilterLicensedStatus !== undefined)
            url_ += "isFilterLicensedStatus=" + encodeURIComponent("" + isFilterLicensedStatus) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBySnomedIdGrouped(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBySnomedIdGrouped(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DeviceBrandFamilyViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DeviceBrandFamilyViewDto>;
        }));
    }

    protected processGetBySnomedIdGrouped(response: HttpResponseBase): Observable<DeviceBrandFamilyViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeviceBrandFamilyViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceBrandFamilyViewDto>(null as any);
    }
}

@Injectable()
export class DiagnosticReportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param patientId (optional) 
     * @return Success
     */
    getAll(patientId: string | null | undefined): Observable<DiagnosticReportDto[]> {
        let url_ = this.baseUrl + "/api/services/app/DiagnosticReport/GetAll?";
        if (patientId !== undefined && patientId !== null)
            url_ += "patientId=" + encodeURIComponent("" + patientId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DiagnosticReportDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DiagnosticReportDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<DiagnosticReportDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DiagnosticReportDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DiagnosticReportDto[]>(null as any);
    }
}

@Injectable()
export class DocumentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<DocumentFileDto> {
        let url_ = this.baseUrl + "/api/services/app/Document/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DocumentFileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DocumentFileDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<DocumentFileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DocumentFileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentFileDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param flag (optional) 
     * @return Success
     */
    enableOrDisable(id: number | undefined, flag: boolean | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Document/EnableOrDisable?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (flag === null)
            throw new Error("The parameter 'flag' cannot be null.");
        else if (flag !== undefined)
            url_ += "flag=" + encodeURIComponent("" + flag) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnableOrDisable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnableOrDisable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEnableOrDisable(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    downloadFile(body: DownloadFileInput | undefined): Observable<DownloadFileDto> {
        let url_ = this.baseUrl + "/api/services/app/Document/DownloadFile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DownloadFileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DownloadFileDto>;
        }));
    }

    protected processDownloadFile(response: HttpResponseBase): Observable<DownloadFileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DownloadFileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DownloadFileDto>(null as any);
    }

    /**
     * @param documentId (optional) 
     * @param manufacturerId (optional) 
     * @param bodyStructureGroupId (optional) 
     * @param deviceClassId (optional) 
     * @param deviceFamilyId (optional) 
     * @param file (optional) 
     * @return Success
     */
    basicValidation(documentId: number | null | undefined, manufacturerId: string | null | undefined, bodyStructureGroupId: string | null | undefined, deviceClassId: string | null | undefined, deviceFamilyId: number | null | undefined, file: FileParameter | null | undefined): Observable<ValidationResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/Document/BasicValidation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (documentId !== null && documentId !== undefined)
            content_.append("DocumentId", documentId.toString());
        if (manufacturerId !== null && manufacturerId !== undefined)
            content_.append("ManufacturerId", manufacturerId.toString());
        if (bodyStructureGroupId !== null && bodyStructureGroupId !== undefined)
            content_.append("BodyStructureGroupId", bodyStructureGroupId.toString());
        if (deviceClassId !== null && deviceClassId !== undefined)
            content_.append("DeviceClassId", deviceClassId.toString());
        if (deviceFamilyId !== null && deviceFamilyId !== undefined)
            content_.append("DeviceFamilyId", deviceFamilyId.toString());
        if (file !== null && file !== undefined)
            content_.append("File", file.data, file.fileName ? file.fileName : "File");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBasicValidation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBasicValidation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ValidationResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ValidationResponseDto>;
        }));
    }

    protected processBasicValidation(response: HttpResponseBase): Observable<ValidationResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ValidationResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ValidationResponseDto>(null as any);
    }

    /**
     * @param documentId (optional) 
     * @param manufacturerId (optional) 
     * @param bodyStructureGroupId (optional) 
     * @param deviceClassId (optional) 
     * @param deviceFamilyId (optional) 
     * @param file (optional) 
     * @return Success
     */
    validateDataFiles(documentId: number | null | undefined, manufacturerId: string | null | undefined, bodyStructureGroupId: string | null | undefined, deviceClassId: string | null | undefined, deviceFamilyId: number | null | undefined, file: FileParameter | null | undefined): Observable<ValidationResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/Document/ValidateDataFiles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (documentId !== null && documentId !== undefined)
            content_.append("DocumentId", documentId.toString());
        if (manufacturerId !== null && manufacturerId !== undefined)
            content_.append("ManufacturerId", manufacturerId.toString());
        if (bodyStructureGroupId !== null && bodyStructureGroupId !== undefined)
            content_.append("BodyStructureGroupId", bodyStructureGroupId.toString());
        if (deviceClassId !== null && deviceClassId !== undefined)
            content_.append("DeviceClassId", deviceClassId.toString());
        if (deviceFamilyId !== null && deviceFamilyId !== undefined)
            content_.append("DeviceFamilyId", deviceFamilyId.toString());
        if (file !== null && file !== undefined)
            content_.append("File", file.data, file.fileName ? file.fileName : "File");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateDataFiles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateDataFiles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ValidationResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ValidationResponseDto>;
        }));
    }

    protected processValidateDataFiles(response: HttpResponseBase): Observable<ValidationResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ValidationResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ValidationResponseDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<DocumentFileDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Document/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DocumentFileDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DocumentFileDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<DocumentFileDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DocumentFileDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentFileDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: DocumentFileDto | undefined): Observable<DocumentFileDto> {
        let url_ = this.baseUrl + "/api/services/app/Document/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DocumentFileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DocumentFileDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<DocumentFileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DocumentFileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentFileDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: DocumentFileDto | undefined): Observable<DocumentFileDto> {
        let url_ = this.baseUrl + "/api/services/app/Document/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DocumentFileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DocumentFileDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<DocumentFileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DocumentFileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentFileDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Document/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class EthnicitiesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<EthnicityDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Ethnicities/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EthnicityDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EthnicityDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<EthnicityDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EthnicityDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EthnicityDto[]>(null as any);
    }
}

@Injectable()
export class HospitalsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getByUser(id: number | undefined): Observable<HospitalDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Hospitals/GetByUser?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HospitalDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HospitalDto[]>;
        }));
    }

    protected processGetByUser(response: HttpResponseBase): Observable<HospitalDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(HospitalDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HospitalDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getByHospitalId(id: string | null | undefined): Observable<HospitalDto> {
        let url_ = this.baseUrl + "/api/services/app/Hospitals/GetByHospitalId?";
        if (id !== undefined && id !== null)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByHospitalId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByHospitalId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HospitalDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HospitalDto>;
        }));
    }

    protected processGetByHospitalId(response: HttpResponseBase): Observable<HospitalDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HospitalDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HospitalDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: HospitalDto | undefined): Observable<HospitalDto> {
        let url_ = this.baseUrl + "/api/services/app/Hospitals/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HospitalDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HospitalDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<HospitalDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HospitalDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HospitalDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: HospitalDto | undefined): Observable<HospitalDto> {
        let url_ = this.baseUrl + "/api/services/app/Hospitals/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HospitalDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HospitalDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<HospitalDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HospitalDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HospitalDto>(null as any);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getAllHospitalsMultiSelect(userId: number | null | undefined): Observable<RegionManagementNodeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Hospitals/GetAllHospitalsMultiSelect?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllHospitalsMultiSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllHospitalsMultiSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegionManagementNodeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegionManagementNodeDto[]>;
        }));
    }

    protected processGetAllHospitalsMultiSelect(response: HttpResponseBase): Observable<RegionManagementNodeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(RegionManagementNodeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegionManagementNodeDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | null | undefined): Observable<HospitalDto> {
        let url_ = this.baseUrl + "/api/services/app/Hospitals/Get?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HospitalDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HospitalDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<HospitalDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HospitalDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HospitalDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<HospitalDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Hospitals/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HospitalDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HospitalDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<HospitalDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HospitalDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HospitalDtoPagedResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Hospitals/Delete?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class IntegratedCareSystemsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<IntegratedCareSystemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/IntegratedCareSystems/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IntegratedCareSystemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IntegratedCareSystemDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<IntegratedCareSystemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(IntegratedCareSystemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IntegratedCareSystemDto[]>(null as any);
    }
}

@Injectable()
export class ManufacturesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<ManufactureDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Manufactures/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ManufactureDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ManufactureDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ManufactureDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ManufactureDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ManufactureDto[]>(null as any);
    }

    /**
     * @param manufacturerId (optional) 
     * @return Success
     */
    getById(manufacturerId: string | undefined): Observable<ManufactureDto> {
        let url_ = this.baseUrl + "/api/services/app/Manufactures/GetById?";
        if (manufacturerId === null)
            throw new Error("The parameter 'manufacturerId' cannot be null.");
        else if (manufacturerId !== undefined)
            url_ += "manufacturerId=" + encodeURIComponent("" + manufacturerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ManufactureDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ManufactureDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ManufactureDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ManufactureDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ManufactureDto>(null as any);
    }
}

@Injectable()
export class PasswordResetsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param emailAddress (optional) 
     * @return Success
     */
    create(emailAddress: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PasswordResets/Create?";
        if (emailAddress !== undefined && emailAddress !== null)
            url_ += "emailAddress=" + encodeURIComponent("" + emailAddress) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    validate(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PasswordResets/Validate?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processValidate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body: PasswordResetInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PasswordResets/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class PatientsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param hospitalId (optional) 
     * @param keyword (optional) 
     * @return Success
     */
    getByHospital(hospitalId: string | null | undefined, keyword: string | null | undefined): Observable<PatientDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Patients/GetByHospital?";
        if (hospitalId !== undefined && hospitalId !== null)
            url_ += "hospitalId=" + encodeURIComponent("" + hospitalId) + "&";
        if (keyword !== undefined && keyword !== null)
            url_ += "keyword=" + encodeURIComponent("" + keyword) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByHospital(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByHospital(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PatientDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PatientDto[]>;
        }));
    }

    protected processGetByHospital(response: HttpResponseBase): Observable<PatientDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PatientDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PatientDto[]>(null as any);
    }

    /**
     * @param hospitalId (optional) 
     * @param patientId (optional) 
     * @return Success
     */
    getAll(hospitalId: string | null | undefined, patientId: string | null | undefined): Observable<PatientDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Patients/GetAll?";
        if (hospitalId !== undefined && hospitalId !== null)
            url_ += "hospitalId=" + encodeURIComponent("" + hospitalId) + "&";
        if (patientId !== undefined && patientId !== null)
            url_ += "patientId=" + encodeURIComponent("" + patientId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PatientDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PatientDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PatientDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PatientDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PatientDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | null | undefined): Observable<PatientDto> {
        let url_ = this.baseUrl + "/api/services/app/Patients/Get?";
        if (id !== undefined && id !== null)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PatientDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PatientDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PatientDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PatientDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PatientDto>(null as any);
    }
}

@Injectable()
export class PatientSurveysServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param hospitalId (optional) 
     * @param keyword (optional) 
     * @param surgeonId (optional) 
     * @param theaterId (optional) 
     * @param isArchived (optional) 
     * @param bodyStructureGroupId (optional) 
     * @param timezone (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(hospitalId: string | null | undefined, keyword: string | null | undefined, surgeonId: number | null | undefined, theaterId: string | null | undefined, isArchived: boolean | undefined, bodyStructureGroupId: string | null | undefined, timezone: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PatientSurveyDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PatientSurveys/GetAll?";
        if (hospitalId !== undefined && hospitalId !== null)
            url_ += "HospitalId=" + encodeURIComponent("" + hospitalId) + "&";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (surgeonId !== undefined && surgeonId !== null)
            url_ += "SurgeonId=" + encodeURIComponent("" + surgeonId) + "&";
        if (theaterId !== undefined && theaterId !== null)
            url_ += "TheaterId=" + encodeURIComponent("" + theaterId) + "&";
        if (isArchived === null)
            throw new Error("The parameter 'isArchived' cannot be null.");
        else if (isArchived !== undefined)
            url_ += "IsArchived=" + encodeURIComponent("" + isArchived) + "&";
        if (bodyStructureGroupId !== undefined && bodyStructureGroupId !== null)
            url_ += "BodyStructureGroupId=" + encodeURIComponent("" + bodyStructureGroupId) + "&";
        if (timezone !== undefined && timezone !== null)
            url_ += "Timezone=" + encodeURIComponent("" + timezone) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PatientSurveyDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PatientSurveyDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PatientSurveyDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PatientSurveyDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PatientSurveyDtoPagedResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<PatientSurveyDto> {
        let url_ = this.baseUrl + "/api/services/app/PatientSurveys/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PatientSurveyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PatientSurveyDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PatientSurveyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PatientSurveyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PatientSurveyDto>(null as any);
    }

    /**
     * @param surveyId (optional) 
     * @param timezone (optional) 
     * @return Success
     */
    getSurvey(surveyId: string | undefined, timezone: string | null | undefined): Observable<PatientSurveyDto> {
        let url_ = this.baseUrl + "/api/services/app/PatientSurveys/GetSurvey?";
        if (surveyId === null)
            throw new Error("The parameter 'surveyId' cannot be null.");
        else if (surveyId !== undefined)
            url_ += "surveyId=" + encodeURIComponent("" + surveyId) + "&";
        if (timezone !== undefined && timezone !== null)
            url_ += "timezone=" + encodeURIComponent("" + timezone) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSurvey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSurvey(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PatientSurveyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PatientSurveyDto>;
        }));
    }

    protected processGetSurvey(response: HttpResponseBase): Observable<PatientSurveyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PatientSurveyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PatientSurveyDto>(null as any);
    }

    /**
     * @param hospitalId (optional) 
     * @return Success
     */
    getSurgeons(hospitalId: string | null | undefined): Observable<UserDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PatientSurveys/GetSurgeons?";
        if (hospitalId !== undefined && hospitalId !== null)
            url_ += "hospitalId=" + encodeURIComponent("" + hospitalId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSurgeons(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSurgeons(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto[]>;
        }));
    }

    protected processGetSurgeons(response: HttpResponseBase): Observable<UserDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(UserDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto[]>(null as any);
    }

    /**
     * @param surveyId (optional) 
     * @param dateStart (optional) 
     * @param timezone (optional) 
     * @return Success
     */
    saveSurveyStartTime(surveyId: string | undefined, dateStart: moment.Moment | undefined, timezone: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PatientSurveys/SaveSurveyStartTime?";
        if (surveyId === null)
            throw new Error("The parameter 'surveyId' cannot be null.");
        else if (surveyId !== undefined)
            url_ += "surveyId=" + encodeURIComponent("" + surveyId) + "&";
        if (dateStart === null)
            throw new Error("The parameter 'dateStart' cannot be null.");
        else if (dateStart !== undefined)
            url_ += "dateStart=" + encodeURIComponent(dateStart ? "" + dateStart.toISOString() : "") + "&";
        if (timezone !== undefined && timezone !== null)
            url_ += "timezone=" + encodeURIComponent("" + timezone) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveSurveyStartTime(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveSurveyStartTime(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveSurveyStartTime(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param patientSurveyId (optional) 
     * @param body (optional) 
     * @return Success
     */
    saveSurveyNotes(patientSurveyId: string | undefined, body: PatientSurveyNotesDto[] | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/PatientSurveys/SaveSurveyNotes?";
        if (patientSurveyId === null)
            throw new Error("The parameter 'patientSurveyId' cannot be null.");
        else if (patientSurveyId !== undefined)
            url_ += "patientSurveyId=" + encodeURIComponent("" + patientSurveyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveSurveyNotes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveSurveyNotes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processSaveSurveyNotes(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @param hospitalId (optional) 
     * @return Success
     */
    getTheaterIds(hospitalId: string | null | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/PatientSurveys/GetTheaterIds?";
        if (hospitalId !== undefined && hospitalId !== null)
            url_ += "hospitalId=" + encodeURIComponent("" + hospitalId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTheaterIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTheaterIds(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetTheaterIds(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(null as any);
    }

    /**
     * @param hospitalId (optional) 
     * @return Success
     */
    getBodyStructureGroups(hospitalId: string | null | undefined): Observable<BodyStructureGroupDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PatientSurveys/GetBodyStructureGroups?";
        if (hospitalId !== undefined && hospitalId !== null)
            url_ += "hospitalId=" + encodeURIComponent("" + hospitalId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBodyStructureGroups(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBodyStructureGroups(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BodyStructureGroupDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BodyStructureGroupDto[]>;
        }));
    }

    protected processGetBodyStructureGroups(response: HttpResponseBase): Observable<BodyStructureGroupDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BodyStructureGroupDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BodyStructureGroupDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: PatientSurveyDto | undefined): Observable<PatientSurveyDto> {
        let url_ = this.baseUrl + "/api/services/app/PatientSurveys/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PatientSurveyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PatientSurveyDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<PatientSurveyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PatientSurveyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PatientSurveyDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePatientSurvey(body: PatientSurveyDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PatientSurveys/UpdatePatientSurvey";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePatientSurvey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePatientSurvey(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdatePatientSurvey(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param surveyId (optional) 
     * @param observerNotes (optional) 
     * @return Success
     */
    updateNotes(surveyId: string | undefined, observerNotes: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PatientSurveys/UpdateNotes?";
        if (surveyId === null)
            throw new Error("The parameter 'surveyId' cannot be null.");
        else if (surveyId !== undefined)
            url_ += "surveyId=" + encodeURIComponent("" + surveyId) + "&";
        if (observerNotes !== undefined && observerNotes !== null)
            url_ += "observerNotes=" + encodeURIComponent("" + observerNotes) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateNotes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateNotes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateNotes(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param poapProcedureId (optional) 
     * @param actualTime (optional) 
     * @param clockStartTimestamp (optional) 
     * @param clockEndTimestamp (optional) 
     * @param timezone (optional) 
     * @return Success
     */
    updateProcedureActualTime(poapProcedureId: string | undefined, actualTime: number | undefined, clockStartTimestamp: moment.Moment | null | undefined, clockEndTimestamp: moment.Moment | null | undefined, timezone: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PatientSurveys/UpdateProcedureActualTime?";
        if (poapProcedureId === null)
            throw new Error("The parameter 'poapProcedureId' cannot be null.");
        else if (poapProcedureId !== undefined)
            url_ += "poapProcedureId=" + encodeURIComponent("" + poapProcedureId) + "&";
        if (actualTime === null)
            throw new Error("The parameter 'actualTime' cannot be null.");
        else if (actualTime !== undefined)
            url_ += "actualTime=" + encodeURIComponent("" + actualTime) + "&";
        if (clockStartTimestamp !== undefined && clockStartTimestamp !== null)
            url_ += "clockStartTimestamp=" + encodeURIComponent(clockStartTimestamp ? "" + clockStartTimestamp.toISOString() : "") + "&";
        if (clockEndTimestamp !== undefined && clockEndTimestamp !== null)
            url_ += "clockEndTimestamp=" + encodeURIComponent(clockEndTimestamp ? "" + clockEndTimestamp.toISOString() : "") + "&";
        if (timezone !== undefined && timezone !== null)
            url_ += "timezone=" + encodeURIComponent("" + timezone) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProcedureActualTime(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProcedureActualTime(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateProcedureActualTime(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param preOperativeAssessmentId (optional) 
     * @param body (optional) 
     * @return Success
     */
    upateProceduresDisplayOrder(preOperativeAssessmentId: string | undefined, body: PoapProcedureDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PatientSurveys/UpateProceduresDisplayOrder?";
        if (preOperativeAssessmentId === null)
            throw new Error("The parameter 'preOperativeAssessmentId' cannot be null.");
        else if (preOperativeAssessmentId !== undefined)
            url_ += "PreOperativeAssessmentId=" + encodeURIComponent("" + preOperativeAssessmentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpateProceduresDisplayOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpateProceduresDisplayOrder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpateProceduresDisplayOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param poapProcedureId (optional) 
     * @param preOperativeAssessmentId (optional) 
     * @return Success
     */
    replicateProcedure(poapProcedureId: string | undefined, preOperativeAssessmentId: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PatientSurveys/ReplicateProcedure?";
        if (poapProcedureId === null)
            throw new Error("The parameter 'poapProcedureId' cannot be null.");
        else if (poapProcedureId !== undefined)
            url_ += "poapProcedureId=" + encodeURIComponent("" + poapProcedureId) + "&";
        if (preOperativeAssessmentId === null)
            throw new Error("The parameter 'preOperativeAssessmentId' cannot be null.");
        else if (preOperativeAssessmentId !== undefined)
            url_ += "preOperativeAssessmentId=" + encodeURIComponent("" + preOperativeAssessmentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplicateProcedure(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplicateProcedure(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processReplicateProcedure(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param displayCompletedSurveySetting (optional) 
     * @return Success
     */
    saveDisplayCompletedSurveySetting(displayCompletedSurveySetting: boolean | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PatientSurveys/SaveDisplayCompletedSurveySetting?";
        if (displayCompletedSurveySetting === null)
            throw new Error("The parameter 'displayCompletedSurveySetting' cannot be null.");
        else if (displayCompletedSurveySetting !== undefined)
            url_ += "displayCompletedSurveySetting=" + encodeURIComponent("" + displayCompletedSurveySetting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveDisplayCompletedSurveySetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveDisplayCompletedSurveySetting(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveDisplayCompletedSurveySetting(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getDisplayCompletedSurveySetting(): Observable<UserDisplayCompletedSurveySettingDto> {
        let url_ = this.baseUrl + "/api/services/app/PatientSurveys/GetDisplayCompletedSurveySetting";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDisplayCompletedSurveySetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDisplayCompletedSurveySetting(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDisplayCompletedSurveySettingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDisplayCompletedSurveySettingDto>;
        }));
    }

    protected processGetDisplayCompletedSurveySetting(response: HttpResponseBase): Observable<UserDisplayCompletedSurveySettingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDisplayCompletedSurveySettingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDisplayCompletedSurveySettingDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: PatientSurveyDto | undefined): Observable<PatientSurveyDto> {
        let url_ = this.baseUrl + "/api/services/app/PatientSurveys/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PatientSurveyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PatientSurveyDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<PatientSurveyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PatientSurveyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PatientSurveyDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PatientSurveys/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class PoapInstrumentPacksServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllInstrumentPacks(): Observable<InstrumentPackDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PoapInstrumentPacksService/GetAllInstrumentPacks";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllInstrumentPacks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllInstrumentPacks(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InstrumentPackDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InstrumentPackDto[]>;
        }));
    }

    protected processGetAllInstrumentPacks(response: HttpResponseBase): Observable<InstrumentPackDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(InstrumentPackDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InstrumentPackDto[]>(null as any);
    }
}

@Injectable()
export class PoapProcedureDevicesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param poapProcedureId (optional) 
     * @param poapId (optional) 
     * @return Success
     */
    getByProcedureId(poapProcedureId: string | null | undefined, poapId: string | null | undefined): Observable<PoapProcedureDevicesDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PoapProcedureDevices/GetByProcedureId?";
        if (poapProcedureId !== undefined && poapProcedureId !== null)
            url_ += "poapProcedureId=" + encodeURIComponent("" + poapProcedureId) + "&";
        if (poapId !== undefined && poapId !== null)
            url_ += "poapId=" + encodeURIComponent("" + poapId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByProcedureId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByProcedureId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PoapProcedureDevicesDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PoapProcedureDevicesDto[]>;
        }));
    }

    protected processGetByProcedureId(response: HttpResponseBase): Observable<PoapProcedureDevicesDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PoapProcedureDevicesDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PoapProcedureDevicesDto[]>(null as any);
    }

    /**
     * @param poapId (optional) 
     * @param poapProcedureId (optional) 
     * @param snomedId (optional) 
     * @param body (optional) 
     * @return Success
     */
    savePoapProcedureDevices(poapId: string | undefined, poapProcedureId: string | undefined, snomedId: string | null | undefined, body: DeviceDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PoapProcedureDevices/SavePoapProcedureDevices?";
        if (poapId === null)
            throw new Error("The parameter 'poapId' cannot be null.");
        else if (poapId !== undefined)
            url_ += "poapId=" + encodeURIComponent("" + poapId) + "&";
        if (poapProcedureId === null)
            throw new Error("The parameter 'poapProcedureId' cannot be null.");
        else if (poapProcedureId !== undefined)
            url_ += "poapProcedureId=" + encodeURIComponent("" + poapProcedureId) + "&";
        if (snomedId !== undefined && snomedId !== null)
            url_ += "snomedId=" + encodeURIComponent("" + snomedId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSavePoapProcedureDevices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSavePoapProcedureDevices(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSavePoapProcedureDevices(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class PoapRiskFactorServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<PoapRiskFactorDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PoapRiskFactor/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PoapRiskFactorDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PoapRiskFactorDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PoapRiskFactorDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PoapRiskFactorDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PoapRiskFactorDto[]>(null as any);
    }
}

@Injectable()
export class PreOperativeAssessmentsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param hospitalId (optional) 
     * @param keyword (optional) 
     * @param isDisplayRiskAwaitingCompletion (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(hospitalId: string | null | undefined, keyword: string | null | undefined, isDisplayRiskAwaitingCompletion: boolean | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PreOperativeAssessmentDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PreOperativeAssessments/GetAll?";
        if (hospitalId !== undefined && hospitalId !== null)
            url_ += "HospitalId=" + encodeURIComponent("" + hospitalId) + "&";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isDisplayRiskAwaitingCompletion === null)
            throw new Error("The parameter 'isDisplayRiskAwaitingCompletion' cannot be null.");
        else if (isDisplayRiskAwaitingCompletion !== undefined)
            url_ += "isDisplayRiskAwaitingCompletion=" + encodeURIComponent("" + isDisplayRiskAwaitingCompletion) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PreOperativeAssessmentDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PreOperativeAssessmentDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PreOperativeAssessmentDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PreOperativeAssessmentDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PreOperativeAssessmentDtoPagedResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<PreOperativeAssessmentDto> {
        let url_ = this.baseUrl + "/api/services/app/PreOperativeAssessments/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PreOperativeAssessmentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PreOperativeAssessmentDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PreOperativeAssessmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PreOperativeAssessmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PreOperativeAssessmentDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param timezone (optional) 
     * @return Success
     */
    getPoap(id: string | undefined, timezone: string | null | undefined): Observable<PreOperativeAssessmentDto> {
        let url_ = this.baseUrl + "/api/services/app/PreOperativeAssessments/GetPoap?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (timezone !== undefined && timezone !== null)
            url_ += "timezone=" + encodeURIComponent("" + timezone) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPoap(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPoap(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PreOperativeAssessmentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PreOperativeAssessmentDto>;
        }));
    }

    protected processGetPoap(response: HttpResponseBase): Observable<PreOperativeAssessmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PreOperativeAssessmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PreOperativeAssessmentDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: PreOperativeAssessmentDto | undefined): Observable<PreOperativeAssessmentDto> {
        let url_ = this.baseUrl + "/api/services/app/PreOperativeAssessments/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PreOperativeAssessmentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PreOperativeAssessmentDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<PreOperativeAssessmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PreOperativeAssessmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PreOperativeAssessmentDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: PreOperativeAssessmentDto | undefined): Observable<PreOperativeAssessmentDto> {
        let url_ = this.baseUrl + "/api/services/app/PreOperativeAssessments/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PreOperativeAssessmentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PreOperativeAssessmentDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<PreOperativeAssessmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PreOperativeAssessmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PreOperativeAssessmentDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PreOperativeAssessments/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    savePoapRiskFactors(body: PreOperativeAssessmentDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PreOperativeAssessments/SavePoapRiskFactors";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSavePoapRiskFactors(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSavePoapRiskFactors(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSavePoapRiskFactors(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @param body (optional) 
     * @return Success
     */
    saveUnselectedRiskFactors(id: string | undefined, body: DiagnosticRiskFactorsMappingDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PreOperativeAssessments/SaveUnselectedRiskFactors?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveUnselectedRiskFactors(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveUnselectedRiskFactors(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveUnselectedRiskFactors(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setPoapData(body: SetPoapDataInputDto | undefined): Observable<SetPoapDataOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/PreOperativeAssessments/SetPoapData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetPoapData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetPoapData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SetPoapDataOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SetPoapDataOutputDto>;
        }));
    }

    protected processSetPoapData(response: HttpResponseBase): Observable<SetPoapDataOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SetPoapDataOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SetPoapDataOutputDto>(null as any);
    }

    /**
     * @param surgeonId (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getPoapData(surgeonId: number | undefined, startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<GetPoapDataOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/PreOperativeAssessments/GetPoapData?";
        if (surgeonId === null)
            throw new Error("The parameter 'surgeonId' cannot be null.");
        else if (surgeonId !== undefined)
            url_ += "SurgeonId=" + encodeURIComponent("" + surgeonId) + "&";
        if (startDate !== undefined && startDate !== null)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate !== undefined && endDate !== null)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPoapData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPoapData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPoapDataOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPoapDataOutputDto>;
        }));
    }

    protected processGetPoapData(response: HttpResponseBase): Observable<GetPoapDataOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPoapDataOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPoapDataOutputDto>(null as any);
    }

    /**
     * @param theaterId (optional) 
     * @return Success
     */
    getPoapDataByTheater(theaterId: string | undefined): Observable<PreOperativeAssessmentDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PreOperativeAssessments/GetPoapDataByTheater?";
        if (theaterId === null)
            throw new Error("The parameter 'theaterId' cannot be null.");
        else if (theaterId !== undefined)
            url_ += "TheaterId=" + encodeURIComponent("" + theaterId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPoapDataByTheater(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPoapDataByTheater(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PreOperativeAssessmentDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PreOperativeAssessmentDto[]>;
        }));
    }

    protected processGetPoapDataByTheater(response: HttpResponseBase): Observable<PreOperativeAssessmentDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PreOperativeAssessmentDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PreOperativeAssessmentDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllProcedureMethodTypes(): Observable<ProcedureMethodTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PreOperativeAssessments/GetAllProcedureMethodTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProcedureMethodTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProcedureMethodTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProcedureMethodTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProcedureMethodTypeDto[]>;
        }));
    }

    protected processGetAllProcedureMethodTypes(response: HttpResponseBase): Observable<ProcedureMethodTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ProcedureMethodTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProcedureMethodTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllInstrumentPacks(): Observable<InstrumentPackDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PreOperativeAssessments/GetAllInstrumentPacks";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllInstrumentPacks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllInstrumentPacks(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InstrumentPackDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InstrumentPackDto[]>;
        }));
    }

    protected processGetAllInstrumentPacks(response: HttpResponseBase): Observable<InstrumentPackDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(InstrumentPackDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InstrumentPackDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @param awaitingRiskCompletionStatus (optional) 
     * @return Success
     */
    updateAwaitingRiskCompletion(id: string | undefined, awaitingRiskCompletionStatus: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PreOperativeAssessments/UpdateAwaitingRiskCompletion?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (awaitingRiskCompletionStatus === null)
            throw new Error("The parameter 'awaitingRiskCompletionStatus' cannot be null.");
        else if (awaitingRiskCompletionStatus !== undefined)
            url_ += "awaitingRiskCompletionStatus=" + encodeURIComponent("" + awaitingRiskCompletionStatus) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAwaitingRiskCompletion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAwaitingRiskCompletion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateAwaitingRiskCompletion(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class RegionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param countryName (optional) 
     * @return Success
     */
    getAll(countryName: string | null | undefined): Observable<RegionDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Regions/GetAll?";
        if (countryName !== undefined && countryName !== null)
            url_ += "countryName=" + encodeURIComponent("" + countryName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegionDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegionDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<RegionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(RegionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegionDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveUserRealm(body: RegionHospitalMappingDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Regions/SaveUserRealm";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveUserRealm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveUserRealm(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processSaveUserRealm(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateRegionDto | undefined): Observable<CreateRegionDto> {
        let url_ = this.baseUrl + "/api/services/app/Regions/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateRegionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateRegionDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CreateRegionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateRegionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateRegionDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CreateRegionDto | undefined): Observable<CreateRegionDto> {
        let url_ = this.baseUrl + "/api/services/app/Regions/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateRegionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateRegionDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<CreateRegionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateRegionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateRegionDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param type (optional) 
     * @return Success
     */
    delete(id: string | null | undefined, type: string | null | undefined): Observable<DeleteResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/Regions/Delete?";
        if (id !== undefined && id !== null)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (type !== undefined && type !== null)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DeleteResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DeleteResponseDto>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<DeleteResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeleteResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeleteResponseDto>(null as any);
    }

    /**
     * @param isRealm (optional) 
     * @param userId (optional) 
     * @return Success
     */
    getAllRegionData(isRealm: boolean | undefined, userId: number | null | undefined): Observable<RegionManagementNodeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Regions/GetAllRegionData?";
        if (isRealm === null)
            throw new Error("The parameter 'isRealm' cannot be null.");
        else if (isRealm !== undefined)
            url_ += "isRealm=" + encodeURIComponent("" + isRealm) + "&";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRegionData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRegionData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegionManagementNodeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegionManagementNodeDto[]>;
        }));
    }

    protected processGetAllRegionData(response: HttpResponseBase): Observable<RegionManagementNodeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(RegionManagementNodeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegionManagementNodeDto[]>(null as any);
    }

    /**
     * @param ics (optional) 
     * @param parentId (optional) 
     * @param isRealm (optional) 
     * @param userId (optional) 
     * @return Success
     */
    getChildrenCountries(ics: IntegratedCareSystemDto[] | null | undefined, parentId: string | null | undefined, isRealm: boolean | undefined, userId: number | null | undefined): Observable<RegionManagementNodeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Regions/GetChildrenCountries?";
        if (ics !== undefined && ics !== null)
            ics && ics.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "ics[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (parentId !== undefined && parentId !== null)
            url_ += "parentId=" + encodeURIComponent("" + parentId) + "&";
        if (isRealm === null)
            throw new Error("The parameter 'isRealm' cannot be null.");
        else if (isRealm !== undefined)
            url_ += "isRealm=" + encodeURIComponent("" + isRealm) + "&";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetChildrenCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChildrenCountries(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegionManagementNodeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegionManagementNodeDto[]>;
        }));
    }

    protected processGetChildrenCountries(response: HttpResponseBase): Observable<RegionManagementNodeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(RegionManagementNodeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegionManagementNodeDto[]>(null as any);
    }

    /**
     * @param ics (optional) 
     * @param parentId (optional) 
     * @param isRealm (optional) 
     * @param userId (optional) 
     * @param countryName (optional) 
     * @return Success
     */
    getChildrenRegions(ics: IntegratedCareSystemDto[] | null | undefined, parentId: string | null | undefined, isRealm: boolean | undefined, userId: number | null | undefined, countryName: string | null | undefined): Observable<RegionManagementNodeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Regions/GetChildrenRegions?";
        if (ics !== undefined && ics !== null)
            ics && ics.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "ics[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (parentId !== undefined && parentId !== null)
            url_ += "parentId=" + encodeURIComponent("" + parentId) + "&";
        if (isRealm === null)
            throw new Error("The parameter 'isRealm' cannot be null.");
        else if (isRealm !== undefined)
            url_ += "isRealm=" + encodeURIComponent("" + isRealm) + "&";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (countryName !== undefined && countryName !== null)
            url_ += "countryName=" + encodeURIComponent("" + countryName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetChildrenRegions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChildrenRegions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegionManagementNodeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegionManagementNodeDto[]>;
        }));
    }

    protected processGetChildrenRegions(response: HttpResponseBase): Observable<RegionManagementNodeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(RegionManagementNodeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegionManagementNodeDto[]>(null as any);
    }

    /**
     * @param ics (optional) 
     * @param parentId (optional) 
     * @param isRealm (optional) 
     * @param userId (optional) 
     * @param countryName (optional) 
     * @param regionName (optional) 
     * @return Success
     */
    getChildrenTrusts(ics: IntegratedCareSystemDto[] | null | undefined, parentId: string | null | undefined, isRealm: boolean | undefined, userId: number | null | undefined, countryName: string | null | undefined, regionName: string | null | undefined): Observable<RegionManagementNodeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Regions/GetChildrenTrusts?";
        if (ics !== undefined && ics !== null)
            ics && ics.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "ics[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (parentId !== undefined && parentId !== null)
            url_ += "parentId=" + encodeURIComponent("" + parentId) + "&";
        if (isRealm === null)
            throw new Error("The parameter 'isRealm' cannot be null.");
        else if (isRealm !== undefined)
            url_ += "isRealm=" + encodeURIComponent("" + isRealm) + "&";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (countryName !== undefined && countryName !== null)
            url_ += "countryName=" + encodeURIComponent("" + countryName) + "&";
        if (regionName !== undefined && regionName !== null)
            url_ += "regionName=" + encodeURIComponent("" + regionName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetChildrenTrusts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChildrenTrusts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegionManagementNodeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegionManagementNodeDto[]>;
        }));
    }

    protected processGetChildrenTrusts(response: HttpResponseBase): Observable<RegionManagementNodeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(RegionManagementNodeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegionManagementNodeDto[]>(null as any);
    }

    /**
     * @param ics (optional) 
     * @param regionId (optional) 
     * @param countryId (optional) 
     * @param isRealm (optional) 
     * @param countryName (optional) 
     * @param regionName (optional) 
     * @param trustName (optional) 
     * @return Success
     */
    getChildrenHospitals(ics: IntegratedCareSystemDto[] | null | undefined, regionId: string | null | undefined, countryId: string | null | undefined, isRealm: boolean | undefined, countryName: string | null | undefined, regionName: string | null | undefined, trustName: string | null | undefined): Observable<RegionManagementNodeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Regions/GetChildrenHospitals?";
        if (ics !== undefined && ics !== null)
            ics && ics.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "ics[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (regionId !== undefined && regionId !== null)
            url_ += "regionId=" + encodeURIComponent("" + regionId) + "&";
        if (countryId !== undefined && countryId !== null)
            url_ += "countryId=" + encodeURIComponent("" + countryId) + "&";
        if (isRealm === null)
            throw new Error("The parameter 'isRealm' cannot be null.");
        else if (isRealm !== undefined)
            url_ += "isRealm=" + encodeURIComponent("" + isRealm) + "&";
        if (countryName !== undefined && countryName !== null)
            url_ += "countryName=" + encodeURIComponent("" + countryName) + "&";
        if (regionName !== undefined && regionName !== null)
            url_ += "regionName=" + encodeURIComponent("" + regionName) + "&";
        if (trustName !== undefined && trustName !== null)
            url_ += "trustName=" + encodeURIComponent("" + trustName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetChildrenHospitals(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChildrenHospitals(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegionManagementNodeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegionManagementNodeDto[]>;
        }));
    }

    protected processGetChildrenHospitals(response: HttpResponseBase): Observable<RegionManagementNodeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(RegionManagementNodeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegionManagementNodeDto[]>(null as any);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getAllRegionsMultiSelect(userId: number | null | undefined): Observable<RegionManagementNodeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Regions/GetAllRegionsMultiSelect?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRegionsMultiSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRegionsMultiSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegionManagementNodeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegionManagementNodeDto[]>;
        }));
    }

    protected processGetAllRegionsMultiSelect(response: HttpResponseBase): Observable<RegionManagementNodeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(RegionManagementNodeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegionManagementNodeDto[]>(null as any);
    }
}

@Injectable()
export class ReportingSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<ReportingSettingDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ReportingSettings/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReportingSettingDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReportingSettingDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ReportingSettingDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ReportingSettingDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReportingSettingDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveAll(body: ReportingSettingDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ReportingSettings/SaveAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveAll(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param hospitalId (optional) 
     * @return Success
     */
    getByHospitalReportingSetting(hospitalId: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/ReportingSettings/GetByHospitalReportingSetting?";
        if (hospitalId !== undefined && hospitalId !== null)
            url_ += "hospitalId=" + encodeURIComponent("" + hospitalId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByHospitalReportingSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByHospitalReportingSetting(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processGetByHospitalReportingSetting(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }
}

@Injectable()
export class RiskMappingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<RiskMappingSettingDto[]> {
        let url_ = this.baseUrl + "/api/services/app/RiskMapping/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RiskMappingSettingDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RiskMappingSettingDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<RiskMappingSettingDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(RiskMappingSettingDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RiskMappingSettingDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveAll(body: RiskMappingSettingDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RiskMapping/SaveAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveAll(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param hospitalId (optional) 
     * @return Success
     */
    getRiskMappingSettingByHospital(hospitalId: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/RiskMapping/GetRiskMappingSettingByHospital?";
        if (hospitalId !== undefined && hospitalId !== null)
            url_ += "hospitalId=" + encodeURIComponent("" + hospitalId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRiskMappingSettingByHospital(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRiskMappingSettingByHospital(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processGetRiskMappingSettingByHospital(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }
}

@Injectable()
export class RoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateRoleDto | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(null as any);
    }

    /**
     * @param permission (optional) 
     * @return Success
     */
    getRoles(permission: string | null | undefined): Observable<RoleListDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoles?";
        if (permission !== undefined && permission !== null)
            url_ += "Permission=" + encodeURIComponent("" + permission) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleListDtoListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleListDtoListResultDto>;
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<RoleListDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleListDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleListDtoListResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: RoleDto | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getAllPermissions(): Observable<PermissionDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAllPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionDtoListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionDtoListResultDto>;
        }));
    }

    protected processGetAllPermissions(response: HttpResponseBase): Observable<PermissionDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PermissionDtoListResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRoleForEdit(id: number | undefined): Observable<GetRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoleForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetRoleForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetRoleForEditOutput>;
        }));
    }

    protected processGetRoleForEdit(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRoleForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRoleForEditOutput>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<RoleDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<RoleDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class SessionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentLoginInformations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentLoginInformations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetCurrentLoginInformationsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetCurrentLoginInformationsOutput>;
        }));
    }

    protected processGetCurrentLoginInformations(response: HttpResponseBase): Observable<GetCurrentLoginInformationsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCurrentLoginInformationsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCurrentLoginInformationsOutput>(null as any);
    }
}

@Injectable()
export class SurgeonSpecialtiesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getAll(userId: number | undefined): Observable<SurgeonSpecialtyDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SurgeonSpecialties/GetAll?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SurgeonSpecialtyDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SurgeonSpecialtyDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<SurgeonSpecialtyDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SurgeonSpecialtyDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SurgeonSpecialtyDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveAll(body: SurgeonSpecialtyDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SurgeonSpecialties/SaveAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveAll(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class SurveyTimestampServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<SurveyTimestampSettingDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SurveyTimestamp/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SurveyTimestampSettingDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SurveyTimestampSettingDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<SurveyTimestampSettingDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SurveyTimestampSettingDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SurveyTimestampSettingDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveAll(body: SurveyTimestampSettingDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SurveyTimestamp/SaveAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveAll(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateTenantDto | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<TenantDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<TenantDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: TenantDto | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(null as any);
    }
}

@Injectable()
export class TheatersServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param hospitalId (optional) 
     * @param keyword (optional) 
     * @return Success
     */
    search(hospitalId: string | null | undefined, keyword: string | null | undefined): Observable<SearchTheaterDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Theaters/Search?";
        if (hospitalId !== undefined && hospitalId !== null)
            url_ += "hospitalId=" + encodeURIComponent("" + hospitalId) + "&";
        if (keyword !== undefined && keyword !== null)
            url_ += "keyword=" + encodeURIComponent("" + keyword) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SearchTheaterDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SearchTheaterDto[]>;
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<SearchTheaterDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SearchTheaterDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SearchTheaterDto[]>(null as any);
    }

    /**
     * @param hospitalId (optional) 
     * @return Success
     */
    getAllTheaters(hospitalId: string | null | undefined): Observable<SearchTheaterDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Theaters/GetAllTheaters?";
        if (hospitalId !== undefined && hospitalId !== null)
            url_ += "hospitalId=" + encodeURIComponent("" + hospitalId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTheaters(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTheaters(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SearchTheaterDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SearchTheaterDto[]>;
        }));
    }

    protected processGetAllTheaters(response: HttpResponseBase): Observable<SearchTheaterDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SearchTheaterDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SearchTheaterDto[]>(null as any);
    }

    /**
     * @param hospitalId (optional) 
     * @return Success
     */
    getByHospitalId(hospitalId: string | null | undefined): Observable<TheaterDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Theaters/GetByHospitalId?";
        if (hospitalId !== undefined && hospitalId !== null)
            url_ += "hospitalId=" + encodeURIComponent("" + hospitalId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByHospitalId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByHospitalId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TheaterDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TheaterDto[]>;
        }));
    }

    protected processGetByHospitalId(response: HttpResponseBase): Observable<TheaterDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(TheaterDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TheaterDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createTheater(body: TheaterDto | undefined): Observable<OutputDto> {
        let url_ = this.baseUrl + "/api/services/app/Theaters/CreateTheater";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTheater(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTheater(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OutputDto>;
        }));
    }

    protected processCreateTheater(response: HttpResponseBase): Observable<OutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OutputDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<TheaterDto> {
        let url_ = this.baseUrl + "/api/services/app/Theaters/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TheaterDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TheaterDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TheaterDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TheaterDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TheaterDto>(null as any);
    }

    /**
     * @param hospitalId (optional) 
     * @param keyword (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(hospitalId: string | null | undefined, keyword: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<TheaterDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Theaters/GetAll?";
        if (hospitalId !== undefined && hospitalId !== null)
            url_ += "HospitalId=" + encodeURIComponent("" + hospitalId) + "&";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TheaterDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TheaterDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<TheaterDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TheaterDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TheaterDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: OutputDto | undefined): Observable<TheaterDto> {
        let url_ = this.baseUrl + "/api/services/app/Theaters/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TheaterDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TheaterDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<TheaterDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TheaterDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TheaterDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: TheaterDto | undefined): Observable<TheaterDto> {
        let url_ = this.baseUrl + "/api/services/app/Theaters/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TheaterDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TheaterDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<TheaterDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TheaterDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TheaterDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Theaters/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class TokenAuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticate(body: AuthenticateModel | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthenticateResultModel>;
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(null as any);
    }

    /**
     * @return Success
     */
    getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExternalAuthenticationProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExternalAuthenticationProviders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExternalLoginProviderInfoModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExternalLoginProviderInfoModel[]>;
        }));
    }

    protected processGetExternalAuthenticationProviders(response: HttpResponseBase): Observable<ExternalLoginProviderInfoModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ExternalLoginProviderInfoModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalLoginProviderInfoModel[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    externalAuthenticate(body: ExternalAuthenticateModel | undefined): Observable<ExternalAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExternalAuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExternalAuthenticateResultModel>;
        }));
    }

    protected processExternalAuthenticate(response: HttpResponseBase): Observable<ExternalAuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExternalAuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalAuthenticateResultModel>(null as any);
    }
}

@Injectable()
export class TrustIcsMappingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<TrustIcsMappingDto[]> {
        let url_ = this.baseUrl + "/api/services/app/TrustIcsMappings/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TrustIcsMappingDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TrustIcsMappingDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<TrustIcsMappingDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(TrustIcsMappingDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrustIcsMappingDto[]>(null as any);
    }
}

@Injectable()
export class TrustsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param regionId (optional) 
     * @param regionName (optional) 
     * @param fromHospitalManagement (optional) 
     * @param countryName (optional) 
     * @return Success
     */
    getAll(regionId: string | null | undefined, regionName: string | null | undefined, fromHospitalManagement: boolean | undefined, countryName: string | null | undefined): Observable<TrustsDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Trusts/GetAll?";
        if (regionId !== undefined && regionId !== null)
            url_ += "RegionId=" + encodeURIComponent("" + regionId) + "&";
        if (regionName !== undefined && regionName !== null)
            url_ += "regionName=" + encodeURIComponent("" + regionName) + "&";
        if (fromHospitalManagement === null)
            throw new Error("The parameter 'fromHospitalManagement' cannot be null.");
        else if (fromHospitalManagement !== undefined)
            url_ += "fromHospitalManagement=" + encodeURIComponent("" + fromHospitalManagement) + "&";
        if (countryName !== undefined && countryName !== null)
            url_ += "countryName=" + encodeURIComponent("" + countryName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TrustsDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TrustsDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<TrustsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(TrustsDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrustsDto[]>(null as any);
    }
}

@Injectable()
export class UkRegionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<UkRegionDto[]> {
        let url_ = this.baseUrl + "/api/services/app/UkRegions/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UkRegionDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UkRegionDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<UkRegionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(UkRegionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UkRegionDto[]>(null as any);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateUserDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UserDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getRoles(): Observable<RoleDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDtoListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDtoListResultDto>;
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<RoleDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDtoListResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeLanguage(body: ChangeUserLanguageDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangeLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeLanguage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePassword(body: ChangePasswordDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body: ResetPasswordDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param hospitalId (optional) 
     * @return Success
     */
    getSurgeons(keyword: string | null | undefined, hospitalId: string | null | undefined): Observable<UserDto[]> {
        let url_ = this.baseUrl + "/api/services/app/User/GetSurgeons?";
        if (keyword !== undefined && keyword !== null)
            url_ += "keyword=" + encodeURIComponent("" + keyword) + "&";
        if (hospitalId !== undefined && hospitalId !== null)
            url_ += "hospitalId=" + encodeURIComponent("" + hospitalId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSurgeons(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSurgeons(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto[]>;
        }));
    }

    protected processGetSurgeons(response: HttpResponseBase): Observable<UserDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(UserDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto[]>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param hospitalId (optional) 
     * @return Success
     */
    getAnaesthetists(keyword: string | null | undefined, hospitalId: string | null | undefined): Observable<UserDto[]> {
        let url_ = this.baseUrl + "/api/services/app/User/GetAnaesthetists?";
        if (keyword !== undefined && keyword !== null)
            url_ += "keyword=" + encodeURIComponent("" + keyword) + "&";
        if (hospitalId !== undefined && hospitalId !== null)
            url_ += "hospitalId=" + encodeURIComponent("" + hospitalId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAnaesthetists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAnaesthetists(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto[]>;
        }));
    }

    protected processGetAnaesthetists(response: HttpResponseBase): Observable<UserDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(UserDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto[]>(null as any);
    }

    /**
     * @param hospitalId (optional) 
     * @return Success
     */
    getAllSurgeons(hospitalId: string | null | undefined): Observable<UserDto[]> {
        let url_ = this.baseUrl + "/api/services/app/User/GetAllSurgeons?";
        if (hospitalId !== undefined && hospitalId !== null)
            url_ += "hospitalId=" + encodeURIComponent("" + hospitalId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSurgeons(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSurgeons(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto[]>;
        }));
    }

    protected processGetAllSurgeons(response: HttpResponseBase): Observable<UserDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(UserDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto[]>(null as any);
    }

    /**
     * @param hospitalId (optional) 
     * @return Success
     */
    getAllAnaesthetists(hospitalId: string | null | undefined): Observable<UserDto[]> {
        let url_ = this.baseUrl + "/api/services/app/User/GetAllAnaesthetists?";
        if (hospitalId !== undefined && hospitalId !== null)
            url_ += "hospitalId=" + encodeURIComponent("" + hospitalId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAnaesthetists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAnaesthetists(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto[]>;
        }));
    }

    protected processGetAllAnaesthetists(response: HttpResponseBase): Observable<UserDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(UserDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllUserLoggedInRoles(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/GetAllUserLoggedInRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserLoggedInRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserLoggedInRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processGetAllUserLoggedInRoles(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param hospitalId (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined, hospitalId: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<UserDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (hospitalId !== undefined && hospitalId !== null)
            url_ += "HospitalId=" + encodeURIComponent("" + hospitalId) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<UserDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class UserHospitalsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getAll(userId: number | undefined): Observable<UserHospitalDto[]> {
        let url_ = this.baseUrl + "/api/services/app/UserHospitals/GetAll?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserHospitalDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserHospitalDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<UserHospitalDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(UserHospitalDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserHospitalDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveAll(body: UserHospitalDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserHospitals/SaveAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveAll(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName: string;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data;
    }

    clone(): IsTenantAvailableInput {
        const json = this.toJSON();
        let result = new IsTenantAvailableInput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableInput {
    tenancyName: string;
}

export enum TenantAvailabilityState {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantId: number | undefined;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): IsTenantAvailableOutput {
        const json = this.toJSON();
        let result = new IsTenantAvailableOutput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantId: number | undefined;
}

export class RegisterInput implements IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;

    constructor(data?: IRegisterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.password = _data["password"];
            this.captchaResponse = _data["captchaResponse"];
        }
    }

    static fromJS(data: any): RegisterInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["captchaResponse"] = this.captchaResponse;
        return data;
    }

    clone(): RegisterInput {
        const json = this.toJSON();
        let result = new RegisterInput();
        result.init(json);
        return result;
    }
}

export interface IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;
}

export class RegisterOutput implements IRegisterOutput {
    canLogin: boolean;

    constructor(data?: IRegisterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.canLogin = _data["canLogin"];
        }
    }

    static fromJS(data: any): RegisterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        return data;
    }

    clone(): RegisterOutput {
        const json = this.toJSON();
        let result = new RegisterOutput();
        result.init(json);
        return result;
    }
}

export interface IRegisterOutput {
    canLogin: boolean;
}

export class BodyStructureQueryDto implements IBodyStructureQueryDto {
    title: string | undefined;
    query: string | undefined;
    querySimplified: string | undefined;
    queryOrder: number;
    bodyStructureId: number;
    bodyStructure: BodyStructureDto;
    id: string;

    constructor(data?: IBodyStructureQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.query = _data["query"];
            this.querySimplified = _data["querySimplified"];
            this.queryOrder = _data["queryOrder"];
            this.bodyStructureId = _data["bodyStructureId"];
            this.bodyStructure = _data["bodyStructure"] ? BodyStructureDto.fromJS(_data["bodyStructure"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BodyStructureQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new BodyStructureQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["query"] = this.query;
        data["querySimplified"] = this.querySimplified;
        data["queryOrder"] = this.queryOrder;
        data["bodyStructureId"] = this.bodyStructureId;
        data["bodyStructure"] = this.bodyStructure ? this.bodyStructure.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): BodyStructureQueryDto {
        const json = this.toJSON();
        let result = new BodyStructureQueryDto();
        result.init(json);
        return result;
    }
}

export interface IBodyStructureQueryDto {
    title: string | undefined;
    query: string | undefined;
    querySimplified: string | undefined;
    queryOrder: number;
    bodyStructureId: number;
    bodyStructure: BodyStructureDto;
    id: string;
}

export class BodyStructureSubProcedureDto implements IBodyStructureSubProcedureDto {
    snomedId: string | undefined;
    description: string | undefined;
    bodyStructureId: number;
    showButtonDevProc: boolean;
    bodyStructure: BodyStructureDto;
    id: number;

    constructor(data?: IBodyStructureSubProcedureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.snomedId = _data["snomedId"];
            this.description = _data["description"];
            this.bodyStructureId = _data["bodyStructureId"];
            this.showButtonDevProc = _data["showButtonDevProc"];
            this.bodyStructure = _data["bodyStructure"] ? BodyStructureDto.fromJS(_data["bodyStructure"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BodyStructureSubProcedureDto {
        data = typeof data === 'object' ? data : {};
        let result = new BodyStructureSubProcedureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["snomedId"] = this.snomedId;
        data["description"] = this.description;
        data["bodyStructureId"] = this.bodyStructureId;
        data["showButtonDevProc"] = this.showButtonDevProc;
        data["bodyStructure"] = this.bodyStructure ? this.bodyStructure.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): BodyStructureSubProcedureDto {
        const json = this.toJSON();
        let result = new BodyStructureSubProcedureDto();
        result.init(json);
        return result;
    }
}

export interface IBodyStructureSubProcedureDto {
    snomedId: string | undefined;
    description: string | undefined;
    bodyStructureId: number;
    showButtonDevProc: boolean;
    bodyStructure: BodyStructureDto;
    id: number;
}

export class BodyStructureDto implements IBodyStructureDto {
    description: string | undefined;
    displayOrder: number;
    bodyStructureGroup: BodyStructureGroupDto;
    bodyStructureQueries: BodyStructureQueryDto[] | undefined;
    bodyStructureSubProcedures: BodyStructureSubProcedureDto[] | undefined;
    id: number;

    constructor(data?: IBodyStructureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.displayOrder = _data["displayOrder"];
            this.bodyStructureGroup = _data["bodyStructureGroup"] ? BodyStructureGroupDto.fromJS(_data["bodyStructureGroup"]) : <any>undefined;
            if (Array.isArray(_data["bodyStructureQueries"])) {
                this.bodyStructureQueries = [] as any;
                for (let item of _data["bodyStructureQueries"])
                    this.bodyStructureQueries.push(BodyStructureQueryDto.fromJS(item));
            }
            if (Array.isArray(_data["bodyStructureSubProcedures"])) {
                this.bodyStructureSubProcedures = [] as any;
                for (let item of _data["bodyStructureSubProcedures"])
                    this.bodyStructureSubProcedures.push(BodyStructureSubProcedureDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BodyStructureDto {
        data = typeof data === 'object' ? data : {};
        let result = new BodyStructureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["displayOrder"] = this.displayOrder;
        data["bodyStructureGroup"] = this.bodyStructureGroup ? this.bodyStructureGroup.toJSON() : <any>undefined;
        if (Array.isArray(this.bodyStructureQueries)) {
            data["bodyStructureQueries"] = [];
            for (let item of this.bodyStructureQueries)
                data["bodyStructureQueries"].push(item.toJSON());
        }
        if (Array.isArray(this.bodyStructureSubProcedures)) {
            data["bodyStructureSubProcedures"] = [];
            for (let item of this.bodyStructureSubProcedures)
                data["bodyStructureSubProcedures"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }

    clone(): BodyStructureDto {
        const json = this.toJSON();
        let result = new BodyStructureDto();
        result.init(json);
        return result;
    }
}

export interface IBodyStructureDto {
    description: string | undefined;
    displayOrder: number;
    bodyStructureGroup: BodyStructureGroupDto;
    bodyStructureQueries: BodyStructureQueryDto[] | undefined;
    bodyStructureSubProcedures: BodyStructureSubProcedureDto[] | undefined;
    id: number;
}

export enum SurgeonExperienceType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class ManufactureDto implements IManufactureDto {
    name: string | undefined;
    isEnabled: boolean;
    id: string;

    constructor(data?: IManufactureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.isEnabled = _data["isEnabled"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ManufactureDto {
        data = typeof data === 'object' ? data : {};
        let result = new ManufactureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isEnabled"] = this.isEnabled;
        data["id"] = this.id;
        return data;
    }

    clone(): ManufactureDto {
        const json = this.toJSON();
        let result = new ManufactureDto();
        result.init(json);
        return result;
    }
}

export interface IManufactureDto {
    name: string | undefined;
    isEnabled: boolean;
    id: string;
}

export class RegionDto implements IRegionDto {
    name: string | undefined;
    type: string | undefined;
    parentId: string | undefined;
    isEnabled: boolean;
    id: string;

    constructor(data?: IRegionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.type = _data["type"];
            this.parentId = _data["parentId"];
            this.isEnabled = _data["isEnabled"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RegionDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["type"] = this.type;
        data["parentId"] = this.parentId;
        data["isEnabled"] = this.isEnabled;
        data["id"] = this.id;
        return data;
    }

    clone(): RegionDto {
        const json = this.toJSON();
        let result = new RegionDto();
        result.init(json);
        return result;
    }
}

export interface IRegionDto {
    name: string | undefined;
    type: string | undefined;
    parentId: string | undefined;
    isEnabled: boolean;
    id: string;
}

export class CountryDto implements ICountryDto {
    name: string | undefined;
    isEnabled: boolean;
    id: number;

    constructor(data?: ICountryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.isEnabled = _data["isEnabled"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CountryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CountryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isEnabled"] = this.isEnabled;
        data["id"] = this.id;
        return data;
    }

    clone(): CountryDto {
        const json = this.toJSON();
        let result = new CountryDto();
        result.init(json);
        return result;
    }
}

export interface ICountryDto {
    name: string | undefined;
    isEnabled: boolean;
    id: number;
}

export class TrustDto implements ITrustDto {
    region: string | undefined;
    trust: string | undefined;
    groupTrust: string | undefined;
    trustWebsite: string | undefined;
    innovationTeamContactName: string | undefined;
    innovationTeamWebsite: string | undefined;
    contactRole: string | undefined;
    contactNumber: string | undefined;
    contactEmail: string | undefined;
    contacted: boolean;
    id: number;

    constructor(data?: ITrustDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.region = _data["region"];
            this.trust = _data["trust"];
            this.groupTrust = _data["groupTrust"];
            this.trustWebsite = _data["trustWebsite"];
            this.innovationTeamContactName = _data["innovationTeamContactName"];
            this.innovationTeamWebsite = _data["innovationTeamWebsite"];
            this.contactRole = _data["contactRole"];
            this.contactNumber = _data["contactNumber"];
            this.contactEmail = _data["contactEmail"];
            this.contacted = _data["contacted"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TrustDto {
        data = typeof data === 'object' ? data : {};
        let result = new TrustDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["region"] = this.region;
        data["trust"] = this.trust;
        data["groupTrust"] = this.groupTrust;
        data["trustWebsite"] = this.trustWebsite;
        data["innovationTeamContactName"] = this.innovationTeamContactName;
        data["innovationTeamWebsite"] = this.innovationTeamWebsite;
        data["contactRole"] = this.contactRole;
        data["contactNumber"] = this.contactNumber;
        data["contactEmail"] = this.contactEmail;
        data["contacted"] = this.contacted;
        data["id"] = this.id;
        return data;
    }

    clone(): TrustDto {
        const json = this.toJSON();
        let result = new TrustDto();
        result.init(json);
        return result;
    }
}

export interface ITrustDto {
    region: string | undefined;
    trust: string | undefined;
    groupTrust: string | undefined;
    trustWebsite: string | undefined;
    innovationTeamContactName: string | undefined;
    innovationTeamWebsite: string | undefined;
    contactRole: string | undefined;
    contactNumber: string | undefined;
    contactEmail: string | undefined;
    contacted: boolean;
    id: number;
}

export class ReportingSettingDto implements IReportingSettingDto {
    hospitalId: string | undefined;
    hospitalName: string | undefined;
    isEnabled: boolean;
    hospital: HospitalDto;
    id: number;

    constructor(data?: IReportingSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hospitalId = _data["hospitalId"];
            this.hospitalName = _data["hospitalName"];
            this.isEnabled = _data["isEnabled"];
            this.hospital = _data["hospital"] ? HospitalDto.fromJS(_data["hospital"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ReportingSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReportingSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hospitalId"] = this.hospitalId;
        data["hospitalName"] = this.hospitalName;
        data["isEnabled"] = this.isEnabled;
        data["hospital"] = this.hospital ? this.hospital.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): ReportingSettingDto {
        const json = this.toJSON();
        let result = new ReportingSettingDto();
        result.init(json);
        return result;
    }
}

export interface IReportingSettingDto {
    hospitalId: string | undefined;
    hospitalName: string | undefined;
    isEnabled: boolean;
    hospital: HospitalDto;
    id: number;
}

export class RiskMappingSettingDto implements IRiskMappingSettingDto {
    hospitalId: string | undefined;
    hospitalName: string | undefined;
    isEnabled: boolean;
    hospital: HospitalDto;
    id: number;

    constructor(data?: IRiskMappingSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hospitalId = _data["hospitalId"];
            this.hospitalName = _data["hospitalName"];
            this.isEnabled = _data["isEnabled"];
            this.hospital = _data["hospital"] ? HospitalDto.fromJS(_data["hospital"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RiskMappingSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new RiskMappingSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hospitalId"] = this.hospitalId;
        data["hospitalName"] = this.hospitalName;
        data["isEnabled"] = this.isEnabled;
        data["hospital"] = this.hospital ? this.hospital.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): RiskMappingSettingDto {
        const json = this.toJSON();
        let result = new RiskMappingSettingDto();
        result.init(json);
        return result;
    }
}

export interface IRiskMappingSettingDto {
    hospitalId: string | undefined;
    hospitalName: string | undefined;
    isEnabled: boolean;
    hospital: HospitalDto;
    id: number;
}

export class SpecialtyInfoDto implements ISpecialtyInfoDto {
    specialtyId: string;
    hospitalId: string | undefined;
    licenseDesc: string | undefined;
    field1: string | undefined;
    field2: string | undefined;
    field3: string | undefined;
    createdBy: number;
    createdDate: moment.Moment;
    specialtyName: string | undefined;
    isSelected: boolean;
    id: number;

    constructor(data?: ISpecialtyInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.specialtyId = _data["specialtyId"];
            this.hospitalId = _data["hospitalId"];
            this.licenseDesc = _data["licenseDesc"];
            this.field1 = _data["field1"];
            this.field2 = _data["field2"];
            this.field3 = _data["field3"];
            this.createdBy = _data["createdBy"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.specialtyName = _data["specialtyName"];
            this.isSelected = _data["isSelected"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SpecialtyInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new SpecialtyInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["specialtyId"] = this.specialtyId;
        data["hospitalId"] = this.hospitalId;
        data["licenseDesc"] = this.licenseDesc;
        data["field1"] = this.field1;
        data["field2"] = this.field2;
        data["field3"] = this.field3;
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["specialtyName"] = this.specialtyName;
        data["isSelected"] = this.isSelected;
        data["id"] = this.id;
        return data;
    }

    clone(): SpecialtyInfoDto {
        const json = this.toJSON();
        let result = new SpecialtyInfoDto();
        result.init(json);
        return result;
    }
}

export interface ISpecialtyInfoDto {
    specialtyId: string;
    hospitalId: string | undefined;
    licenseDesc: string | undefined;
    field1: string | undefined;
    field2: string | undefined;
    field3: string | undefined;
    createdBy: number;
    createdDate: moment.Moment;
    specialtyName: string | undefined;
    isSelected: boolean;
    id: number;
}

export class HospitalDto implements IHospitalDto {
    name: string | undefined;
    reportUrl: string | undefined;
    countryId: string | undefined;
    regionId: string | undefined;
    trustId: string | undefined;
    icsId: number | undefined;
    countryName: string | undefined;
    regionName: string | undefined;
    trustName: string | undefined;
    postcode: string | undefined;
    activeDevMgt: boolean;
    showButtonDevProc: boolean | undefined;
    country: CountryDto;
    region: RegionDto;
    trust: TrustDto;
    setting: ReportingSettingDto;
    riskMappingSetting: RiskMappingSettingDto;
    specialtyInfos: SpecialtyInfoDto[] | undefined;
    id: string | undefined;

    constructor(data?: IHospitalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.reportUrl = _data["reportUrl"];
            this.countryId = _data["countryId"];
            this.regionId = _data["regionId"];
            this.trustId = _data["trustId"];
            this.icsId = _data["icsId"];
            this.countryName = _data["countryName"];
            this.regionName = _data["regionName"];
            this.trustName = _data["trustName"];
            this.postcode = _data["postcode"];
            this.activeDevMgt = _data["activeDevMgt"];
            this.showButtonDevProc = _data["showButtonDevProc"];
            this.country = _data["country"] ? CountryDto.fromJS(_data["country"]) : <any>undefined;
            this.region = _data["region"] ? RegionDto.fromJS(_data["region"]) : <any>undefined;
            this.trust = _data["trust"] ? TrustDto.fromJS(_data["trust"]) : <any>undefined;
            this.setting = _data["setting"] ? ReportingSettingDto.fromJS(_data["setting"]) : <any>undefined;
            this.riskMappingSetting = _data["riskMappingSetting"] ? RiskMappingSettingDto.fromJS(_data["riskMappingSetting"]) : <any>undefined;
            if (Array.isArray(_data["specialtyInfos"])) {
                this.specialtyInfos = [] as any;
                for (let item of _data["specialtyInfos"])
                    this.specialtyInfos.push(SpecialtyInfoDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): HospitalDto {
        data = typeof data === 'object' ? data : {};
        let result = new HospitalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["reportUrl"] = this.reportUrl;
        data["countryId"] = this.countryId;
        data["regionId"] = this.regionId;
        data["trustId"] = this.trustId;
        data["icsId"] = this.icsId;
        data["countryName"] = this.countryName;
        data["regionName"] = this.regionName;
        data["trustName"] = this.trustName;
        data["postcode"] = this.postcode;
        data["activeDevMgt"] = this.activeDevMgt;
        data["showButtonDevProc"] = this.showButtonDevProc;
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        data["region"] = this.region ? this.region.toJSON() : <any>undefined;
        data["trust"] = this.trust ? this.trust.toJSON() : <any>undefined;
        data["setting"] = this.setting ? this.setting.toJSON() : <any>undefined;
        data["riskMappingSetting"] = this.riskMappingSetting ? this.riskMappingSetting.toJSON() : <any>undefined;
        if (Array.isArray(this.specialtyInfos)) {
            data["specialtyInfos"] = [];
            for (let item of this.specialtyInfos)
                data["specialtyInfos"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }

    clone(): HospitalDto {
        const json = this.toJSON();
        let result = new HospitalDto();
        result.init(json);
        return result;
    }
}

export interface IHospitalDto {
    name: string | undefined;
    reportUrl: string | undefined;
    countryId: string | undefined;
    regionId: string | undefined;
    trustId: string | undefined;
    icsId: number | undefined;
    countryName: string | undefined;
    regionName: string | undefined;
    trustName: string | undefined;
    postcode: string | undefined;
    activeDevMgt: boolean;
    showButtonDevProc: boolean | undefined;
    country: CountryDto;
    region: RegionDto;
    trust: TrustDto;
    setting: ReportingSettingDto;
    riskMappingSetting: RiskMappingSettingDto;
    specialtyInfos: SpecialtyInfoDto[] | undefined;
    id: string | undefined;
}

export class UserRealmMappingDto implements IUserRealmMappingDto {
    userId: number | undefined;
    regionId: string | undefined;
    hospitalId: string | undefined;
    user: UserDto;
    region: RegionDto;
    hospital: HospitalDto;
    id: string;

    constructor(data?: IUserRealmMappingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.regionId = _data["regionId"];
            this.hospitalId = _data["hospitalId"];
            this.user = _data["user"] ? UserDto.fromJS(_data["user"]) : <any>undefined;
            this.region = _data["region"] ? RegionDto.fromJS(_data["region"]) : <any>undefined;
            this.hospital = _data["hospital"] ? HospitalDto.fromJS(_data["hospital"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserRealmMappingDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRealmMappingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["regionId"] = this.regionId;
        data["hospitalId"] = this.hospitalId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["region"] = this.region ? this.region.toJSON() : <any>undefined;
        data["hospital"] = this.hospital ? this.hospital.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): UserRealmMappingDto {
        const json = this.toJSON();
        let result = new UserRealmMappingDto();
        result.init(json);
        return result;
    }
}

export interface IUserRealmMappingDto {
    userId: number | undefined;
    regionId: string | undefined;
    hospitalId: string | undefined;
    user: UserDto;
    region: RegionDto;
    hospital: HospitalDto;
    id: string;
}

export class UserDto implements IUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment;
    roleNames: string[] | undefined;
    experience: SurgeonExperienceType;
    manufactureId: string | undefined;
    manufactureName: string | undefined;
    manufacture: ManufactureDto;
    userRealmMappings: UserRealmMappingDto[] | undefined;
    userRealmMappingRegions: string | undefined;
    userRealmMappingHospitals: string | undefined;
    id: number;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.isActive = _data["isActive"];
            this.fullName = _data["fullName"];
            this.lastLoginTime = _data["lastLoginTime"] ? moment(_data["lastLoginTime"].toString()) : <any>undefined;
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames.push(item);
            }
            this.experience = _data["experience"];
            this.manufactureId = _data["manufactureId"];
            this.manufactureName = _data["manufactureName"];
            this.manufacture = _data["manufacture"] ? ManufactureDto.fromJS(_data["manufacture"]) : <any>undefined;
            if (Array.isArray(_data["userRealmMappings"])) {
                this.userRealmMappings = [] as any;
                for (let item of _data["userRealmMappings"])
                    this.userRealmMappings.push(UserRealmMappingDto.fromJS(item));
            }
            this.userRealmMappingRegions = _data["userRealmMappingRegions"];
            this.userRealmMappingHospitals = _data["userRealmMappingHospitals"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        data["fullName"] = this.fullName;
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["experience"] = this.experience;
        data["manufactureId"] = this.manufactureId;
        data["manufactureName"] = this.manufactureName;
        data["manufacture"] = this.manufacture ? this.manufacture.toJSON() : <any>undefined;
        if (Array.isArray(this.userRealmMappings)) {
            data["userRealmMappings"] = [];
            for (let item of this.userRealmMappings)
                data["userRealmMappings"].push(item.toJSON());
        }
        data["userRealmMappingRegions"] = this.userRealmMappingRegions;
        data["userRealmMappingHospitals"] = this.userRealmMappingHospitals;
        data["id"] = this.id;
        return data;
    }

    clone(): UserDto {
        const json = this.toJSON();
        let result = new UserDto();
        result.init(json);
        return result;
    }
}

export interface IUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment;
    roleNames: string[] | undefined;
    experience: SurgeonExperienceType;
    manufactureId: string | undefined;
    manufactureName: string | undefined;
    manufacture: ManufactureDto;
    userRealmMappings: UserRealmMappingDto[] | undefined;
    userRealmMappingRegions: string | undefined;
    userRealmMappingHospitals: string | undefined;
    id: number;
}

export class SurgeonSpecialtyDto implements ISurgeonSpecialtyDto {
    surgeonId: number;
    bodyStructureGroupId: string;
    bodyStructureName: string | undefined;
    isSelected: boolean;
    user: UserDto;

    constructor(data?: ISurgeonSpecialtyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.surgeonId = _data["surgeonId"];
            this.bodyStructureGroupId = _data["bodyStructureGroupId"];
            this.bodyStructureName = _data["bodyStructureName"];
            this.isSelected = _data["isSelected"];
            this.user = _data["user"] ? UserDto.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SurgeonSpecialtyDto {
        data = typeof data === 'object' ? data : {};
        let result = new SurgeonSpecialtyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["surgeonId"] = this.surgeonId;
        data["bodyStructureGroupId"] = this.bodyStructureGroupId;
        data["bodyStructureName"] = this.bodyStructureName;
        data["isSelected"] = this.isSelected;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }

    clone(): SurgeonSpecialtyDto {
        const json = this.toJSON();
        let result = new SurgeonSpecialtyDto();
        result.init(json);
        return result;
    }
}

export interface ISurgeonSpecialtyDto {
    surgeonId: number;
    bodyStructureGroupId: string;
    bodyStructureName: string | undefined;
    isSelected: boolean;
    user: UserDto;
}

export class BodyStructureGroupDto implements IBodyStructureGroupDto {
    name: string | undefined;
    displayOrder: number;
    bodyStructures: BodyStructureDto[] | undefined;
    surgeonSpecialties: SurgeonSpecialtyDto[] | undefined;
    id: string;

    constructor(data?: IBodyStructureGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayOrder = _data["displayOrder"];
            if (Array.isArray(_data["bodyStructures"])) {
                this.bodyStructures = [] as any;
                for (let item of _data["bodyStructures"])
                    this.bodyStructures.push(BodyStructureDto.fromJS(item));
            }
            if (Array.isArray(_data["surgeonSpecialties"])) {
                this.surgeonSpecialties = [] as any;
                for (let item of _data["surgeonSpecialties"])
                    this.surgeonSpecialties.push(SurgeonSpecialtyDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BodyStructureGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new BodyStructureGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayOrder"] = this.displayOrder;
        if (Array.isArray(this.bodyStructures)) {
            data["bodyStructures"] = [];
            for (let item of this.bodyStructures)
                data["bodyStructures"].push(item.toJSON());
        }
        if (Array.isArray(this.surgeonSpecialties)) {
            data["surgeonSpecialties"] = [];
            for (let item of this.surgeonSpecialties)
                data["surgeonSpecialties"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }

    clone(): BodyStructureGroupDto {
        const json = this.toJSON();
        let result = new BodyStructureGroupDto();
        result.init(json);
        return result;
    }
}

export interface IBodyStructureGroupDto {
    name: string | undefined;
    displayOrder: number;
    bodyStructures: BodyStructureDto[] | undefined;
    surgeonSpecialties: SurgeonSpecialtyDto[] | undefined;
    id: string;
}

export class ProcedureMethodDto implements IProcedureMethodDto {
    id: string | undefined;
    name: string | undefined;

    constructor(data?: IProcedureMethodDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ProcedureMethodDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProcedureMethodDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): ProcedureMethodDto {
        const json = this.toJSON();
        let result = new ProcedureMethodDto();
        result.init(json);
        return result;
    }
}

export interface IProcedureMethodDto {
    id: string | undefined;
    name: string | undefined;
}

export class MenuItemOutputDto implements IMenuItemOutputDto {
    id: string | undefined;
    name: string | undefined;
    showButtonDevProc: boolean;
    children: MenuItemOutputDto[] | undefined;

    constructor(data?: IMenuItemOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.showButtonDevProc = _data["showButtonDevProc"];
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children.push(MenuItemOutputDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MenuItemOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new MenuItemOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["showButtonDevProc"] = this.showButtonDevProc;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        return data;
    }

    clone(): MenuItemOutputDto {
        const json = this.toJSON();
        let result = new MenuItemOutputDto();
        result.init(json);
        return result;
    }
}

export interface IMenuItemOutputDto {
    id: string | undefined;
    name: string | undefined;
    showButtonDevProc: boolean;
    children: MenuItemOutputDto[] | undefined;
}

export class ComorbidityDto implements IComorbidityDto {
    snomedId: string | undefined;
    description: string | undefined;

    constructor(data?: IComorbidityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.snomedId = _data["snomedId"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): ComorbidityDto {
        data = typeof data === 'object' ? data : {};
        let result = new ComorbidityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["snomedId"] = this.snomedId;
        data["description"] = this.description;
        return data;
    }

    clone(): ComorbidityDto {
        const json = this.toJSON();
        let result = new ComorbidityDto();
        result.init(json);
        return result;
    }
}

export interface IComorbidityDto {
    snomedId: string | undefined;
    description: string | undefined;
}

export class CoMorbidityGroupDto implements ICoMorbidityGroupDto {
    id: number;
    description: string | undefined;
    comorbidities: ComorbidityDto[] | undefined;
    snomedId: string | undefined;

    constructor(data?: ICoMorbidityGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.description = _data["description"];
            if (Array.isArray(_data["comorbidities"])) {
                this.comorbidities = [] as any;
                for (let item of _data["comorbidities"])
                    this.comorbidities.push(ComorbidityDto.fromJS(item));
            }
            this.snomedId = _data["snomedId"];
        }
    }

    static fromJS(data: any): CoMorbidityGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new CoMorbidityGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        if (Array.isArray(this.comorbidities)) {
            data["comorbidities"] = [];
            for (let item of this.comorbidities)
                data["comorbidities"].push(item.toJSON());
        }
        data["snomedId"] = this.snomedId;
        return data;
    }

    clone(): CoMorbidityGroupDto {
        const json = this.toJSON();
        let result = new CoMorbidityGroupDto();
        result.init(json);
        return result;
    }
}

export interface ICoMorbidityGroupDto {
    id: number;
    description: string | undefined;
    comorbidities: ComorbidityDto[] | undefined;
    snomedId: string | undefined;
}

export class ChangeUiThemeInput implements IChangeUiThemeInput {
    theme: string;

    constructor(data?: IChangeUiThemeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.theme = _data["theme"];
        }
    }

    static fromJS(data: any): ChangeUiThemeInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUiThemeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["theme"] = this.theme;
        return data;
    }

    clone(): ChangeUiThemeInput {
        const json = this.toJSON();
        let result = new ChangeUiThemeInput();
        result.init(json);
        return result;
    }
}

export interface IChangeUiThemeInput {
    theme: string;
}

export class DeviceClassDto implements IDeviceClassDto {
    class: string | undefined;
    rule: string | undefined;
    field1: string | undefined;
    field2: string | undefined;
    field3: string | undefined;
    id: string;

    constructor(data?: IDeviceClassDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.class = _data["class"];
            this.rule = _data["rule"];
            this.field1 = _data["field1"];
            this.field2 = _data["field2"];
            this.field3 = _data["field3"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DeviceClassDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceClassDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["class"] = this.class;
        data["rule"] = this.rule;
        data["field1"] = this.field1;
        data["field2"] = this.field2;
        data["field3"] = this.field3;
        data["id"] = this.id;
        return data;
    }

    clone(): DeviceClassDto {
        const json = this.toJSON();
        let result = new DeviceClassDto();
        result.init(json);
        return result;
    }
}

export interface IDeviceClassDto {
    class: string | undefined;
    rule: string | undefined;
    field1: string | undefined;
    field2: string | undefined;
    field3: string | undefined;
    id: string;
}

export class DeviceFamilyDto implements IDeviceFamilyDto {
    deviceFamilyId: string;
    name: string | undefined;
    field1: string | undefined;
    field2: string | undefined;
    field3: string | undefined;
    bodyStructureGroupId: string | undefined;
    id: number;

    constructor(data?: IDeviceFamilyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceFamilyId = _data["deviceFamilyId"];
            this.name = _data["name"];
            this.field1 = _data["field1"];
            this.field2 = _data["field2"];
            this.field3 = _data["field3"];
            this.bodyStructureGroupId = _data["bodyStructureGroupId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DeviceFamilyDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceFamilyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceFamilyId"] = this.deviceFamilyId;
        data["name"] = this.name;
        data["field1"] = this.field1;
        data["field2"] = this.field2;
        data["field3"] = this.field3;
        data["bodyStructureGroupId"] = this.bodyStructureGroupId;
        data["id"] = this.id;
        return data;
    }

    clone(): DeviceFamilyDto {
        const json = this.toJSON();
        let result = new DeviceFamilyDto();
        result.init(json);
        return result;
    }
}

export interface IDeviceFamilyDto {
    deviceFamilyId: string;
    name: string | undefined;
    field1: string | undefined;
    field2: string | undefined;
    field3: string | undefined;
    bodyStructureGroupId: string | undefined;
    id: number;
}

export class DeviceDto implements IDeviceDto {
    uid: string | undefined;
    gmdnTermCode: string | undefined;
    deviceName: string | undefined;
    deviceDescription: string | undefined;
    brandName: string | undefined;
    model: string | undefined;
    manufacturerId: string | undefined;
    docFileId: number | undefined;
    status: number;
    userId: number;
    createdDate: moment.Moment;
    modifiedDate: moment.Moment | undefined;
    modifiedBy: number | undefined;
    bodyStructureGroupId: string | undefined;
    deviceLookupDesc: string | undefined;
    deviceClassId: string | undefined;
    deviceFamilyId: number | undefined;
    gS1Code: string | undefined;
    gtinCode: number | undefined;
    specialtyName: string | undefined;
    statusName: string | undefined;
    isAvailable: boolean;
    deviceClassName: string | undefined;
    manufacturerName: string | undefined;
    superAdminUser: boolean;
    manufacturer: ManufactureDto;
    bodyStructureGroup: BodyStructureGroupDto;
    deviceClass: DeviceClassDto;
    deviceFamily: DeviceFamilyDto;
    id: number;

    constructor(data?: IDeviceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.uid = _data["uid"];
            this.gmdnTermCode = _data["gmdnTermCode"];
            this.deviceName = _data["deviceName"];
            this.deviceDescription = _data["deviceDescription"];
            this.brandName = _data["brandName"];
            this.model = _data["model"];
            this.manufacturerId = _data["manufacturerId"];
            this.docFileId = _data["docFileId"];
            this.status = _data["status"];
            this.userId = _data["userId"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? moment(_data["modifiedDate"].toString()) : <any>undefined;
            this.modifiedBy = _data["modifiedBy"];
            this.bodyStructureGroupId = _data["bodyStructureGroupId"];
            this.deviceLookupDesc = _data["deviceLookupDesc"];
            this.deviceClassId = _data["deviceClassId"];
            this.deviceFamilyId = _data["deviceFamilyId"];
            this.gS1Code = _data["gS1Code"];
            this.gtinCode = _data["gtinCode"];
            this.specialtyName = _data["specialtyName"];
            this.statusName = _data["statusName"];
            this.isAvailable = _data["isAvailable"];
            this.deviceClassName = _data["deviceClassName"];
            this.manufacturerName = _data["manufacturerName"];
            this.superAdminUser = _data["superAdminUser"];
            this.manufacturer = _data["manufacturer"] ? ManufactureDto.fromJS(_data["manufacturer"]) : <any>undefined;
            this.bodyStructureGroup = _data["bodyStructureGroup"] ? BodyStructureGroupDto.fromJS(_data["bodyStructureGroup"]) : <any>undefined;
            this.deviceClass = _data["deviceClass"] ? DeviceClassDto.fromJS(_data["deviceClass"]) : <any>undefined;
            this.deviceFamily = _data["deviceFamily"] ? DeviceFamilyDto.fromJS(_data["deviceFamily"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DeviceDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uid"] = this.uid;
        data["gmdnTermCode"] = this.gmdnTermCode;
        data["deviceName"] = this.deviceName;
        data["deviceDescription"] = this.deviceDescription;
        data["brandName"] = this.brandName;
        data["model"] = this.model;
        data["manufacturerId"] = this.manufacturerId;
        data["docFileId"] = this.docFileId;
        data["status"] = this.status;
        data["userId"] = this.userId;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["modifiedBy"] = this.modifiedBy;
        data["bodyStructureGroupId"] = this.bodyStructureGroupId;
        data["deviceLookupDesc"] = this.deviceLookupDesc;
        data["deviceClassId"] = this.deviceClassId;
        data["deviceFamilyId"] = this.deviceFamilyId;
        data["gS1Code"] = this.gS1Code;
        data["gtinCode"] = this.gtinCode;
        data["specialtyName"] = this.specialtyName;
        data["statusName"] = this.statusName;
        data["isAvailable"] = this.isAvailable;
        data["deviceClassName"] = this.deviceClassName;
        data["manufacturerName"] = this.manufacturerName;
        data["superAdminUser"] = this.superAdminUser;
        data["manufacturer"] = this.manufacturer ? this.manufacturer.toJSON() : <any>undefined;
        data["bodyStructureGroup"] = this.bodyStructureGroup ? this.bodyStructureGroup.toJSON() : <any>undefined;
        data["deviceClass"] = this.deviceClass ? this.deviceClass.toJSON() : <any>undefined;
        data["deviceFamily"] = this.deviceFamily ? this.deviceFamily.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): DeviceDto {
        const json = this.toJSON();
        let result = new DeviceDto();
        result.init(json);
        return result;
    }
}

export interface IDeviceDto {
    uid: string | undefined;
    gmdnTermCode: string | undefined;
    deviceName: string | undefined;
    deviceDescription: string | undefined;
    brandName: string | undefined;
    model: string | undefined;
    manufacturerId: string | undefined;
    docFileId: number | undefined;
    status: number;
    userId: number;
    createdDate: moment.Moment;
    modifiedDate: moment.Moment | undefined;
    modifiedBy: number | undefined;
    bodyStructureGroupId: string | undefined;
    deviceLookupDesc: string | undefined;
    deviceClassId: string | undefined;
    deviceFamilyId: number | undefined;
    gS1Code: string | undefined;
    gtinCode: number | undefined;
    specialtyName: string | undefined;
    statusName: string | undefined;
    isAvailable: boolean;
    deviceClassName: string | undefined;
    manufacturerName: string | undefined;
    superAdminUser: boolean;
    manufacturer: ManufactureDto;
    bodyStructureGroup: BodyStructureGroupDto;
    deviceClass: DeviceClassDto;
    deviceFamily: DeviceFamilyDto;
    id: number;
}

export class DevicesTermCodeDto implements IDevicesTermCodeDto {
    gmdnTermCode: string | undefined;
    deviceName: string | undefined;
    deviceDescription: string | undefined;
    brandName: string | undefined;
    manufacturerId: string | undefined;
    manufacturerName: string | undefined;
    gmdnDefinition: string | undefined;
    gmdnStatus: string | undefined;
    gmdnTermIsIVD: string | undefined;
    gmdnCreatedDate: string | undefined;
    gmdnObsoletedDate: string | undefined;

    constructor(data?: IDevicesTermCodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gmdnTermCode = _data["gmdnTermCode"];
            this.deviceName = _data["deviceName"];
            this.deviceDescription = _data["deviceDescription"];
            this.brandName = _data["brandName"];
            this.manufacturerId = _data["manufacturerId"];
            this.manufacturerName = _data["manufacturerName"];
            this.gmdnDefinition = _data["gmdnDefinition"];
            this.gmdnStatus = _data["gmdnStatus"];
            this.gmdnTermIsIVD = _data["gmdnTermIsIVD"];
            this.gmdnCreatedDate = _data["gmdnCreatedDate"];
            this.gmdnObsoletedDate = _data["gmdnObsoletedDate"];
        }
    }

    static fromJS(data: any): DevicesTermCodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new DevicesTermCodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gmdnTermCode"] = this.gmdnTermCode;
        data["deviceName"] = this.deviceName;
        data["deviceDescription"] = this.deviceDescription;
        data["brandName"] = this.brandName;
        data["manufacturerId"] = this.manufacturerId;
        data["manufacturerName"] = this.manufacturerName;
        data["gmdnDefinition"] = this.gmdnDefinition;
        data["gmdnStatus"] = this.gmdnStatus;
        data["gmdnTermIsIVD"] = this.gmdnTermIsIVD;
        data["gmdnCreatedDate"] = this.gmdnCreatedDate;
        data["gmdnObsoletedDate"] = this.gmdnObsoletedDate;
        return data;
    }

    clone(): DevicesTermCodeDto {
        const json = this.toJSON();
        let result = new DevicesTermCodeDto();
        result.init(json);
        return result;
    }
}

export interface IDevicesTermCodeDto {
    gmdnTermCode: string | undefined;
    deviceName: string | undefined;
    deviceDescription: string | undefined;
    brandName: string | undefined;
    manufacturerId: string | undefined;
    manufacturerName: string | undefined;
    gmdnDefinition: string | undefined;
    gmdnStatus: string | undefined;
    gmdnTermIsIVD: string | undefined;
    gmdnCreatedDate: string | undefined;
    gmdnObsoletedDate: string | undefined;
}

export class DeviceDtoPagedResultDto implements IDeviceDtoPagedResultDto {
    totalCount: number;
    items: DeviceDto[] | undefined;

    constructor(data?: IDeviceDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(DeviceDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DeviceDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): DeviceDtoPagedResultDto {
        const json = this.toJSON();
        let result = new DeviceDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IDeviceDtoPagedResultDto {
    totalCount: number;
    items: DeviceDto[] | undefined;
}

export class TreeNodeGroup implements ITreeNodeGroup {
    group: string | undefined;
    isGroup: boolean | undefined;

    constructor(data?: ITreeNodeGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.group = _data["group"];
            this.isGroup = _data["isGroup"];
        }
    }

    static fromJS(data: any): TreeNodeGroup {
        data = typeof data === 'object' ? data : {};
        let result = new TreeNodeGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["group"] = this.group;
        data["isGroup"] = this.isGroup;
        return data;
    }

    clone(): TreeNodeGroup {
        const json = this.toJSON();
        let result = new TreeNodeGroup();
        result.init(json);
        return result;
    }
}

export interface ITreeNodeGroup {
    group: string | undefined;
    isGroup: boolean | undefined;
}

export class TreeNodeInput implements ITreeNodeInput {
    key: string | undefined;
    label: string | undefined;
    partialSelected: boolean | undefined;
    data: TreeNodeGroup;
    children: TreeNodeInput[] | undefined;

    constructor(data?: ITreeNodeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.label = _data["label"];
            this.partialSelected = _data["partialSelected"];
            this.data = _data["data"] ? TreeNodeGroup.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children.push(TreeNodeInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TreeNodeInput {
        data = typeof data === 'object' ? data : {};
        let result = new TreeNodeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["label"] = this.label;
        data["partialSelected"] = this.partialSelected;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        return data;
    }

    clone(): TreeNodeInput {
        const json = this.toJSON();
        let result = new TreeNodeInput();
        result.init(json);
        return result;
    }
}

export interface ITreeNodeInput {
    key: string | undefined;
    label: string | undefined;
    partialSelected: boolean | undefined;
    data: TreeNodeGroup;
    children: TreeNodeInput[] | undefined;
}

export class DeviceBrandFamilyDto implements IDeviceBrandFamilyDto {
    uniqueID: string | undefined;
    brandName: string | undefined;
    deviceFamilyId: number | undefined;
    deviceFamilyName: string | undefined;
    manufacturerId: string | undefined;
    manufacturerName: string | undefined;

    constructor(data?: IDeviceBrandFamilyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.uniqueID = _data["uniqueID"];
            this.brandName = _data["brandName"];
            this.deviceFamilyId = _data["deviceFamilyId"];
            this.deviceFamilyName = _data["deviceFamilyName"];
            this.manufacturerId = _data["manufacturerId"];
            this.manufacturerName = _data["manufacturerName"];
        }
    }

    static fromJS(data: any): DeviceBrandFamilyDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceBrandFamilyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uniqueID"] = this.uniqueID;
        data["brandName"] = this.brandName;
        data["deviceFamilyId"] = this.deviceFamilyId;
        data["deviceFamilyName"] = this.deviceFamilyName;
        data["manufacturerId"] = this.manufacturerId;
        data["manufacturerName"] = this.manufacturerName;
        return data;
    }

    clone(): DeviceBrandFamilyDto {
        const json = this.toJSON();
        let result = new DeviceBrandFamilyDto();
        result.init(json);
        return result;
    }
}

export interface IDeviceBrandFamilyDto {
    uniqueID: string | undefined;
    brandName: string | undefined;
    deviceFamilyId: number | undefined;
    deviceFamilyName: string | undefined;
    manufacturerId: string | undefined;
    manufacturerName: string | undefined;
}

export class DeviceBrandFamilyViewDto implements IDeviceBrandFamilyViewDto {
    isLicensed: boolean;
    deviceBrandFamilies: DeviceBrandFamilyDto[] | undefined;

    constructor(data?: IDeviceBrandFamilyViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isLicensed = _data["isLicensed"];
            if (Array.isArray(_data["deviceBrandFamilies"])) {
                this.deviceBrandFamilies = [] as any;
                for (let item of _data["deviceBrandFamilies"])
                    this.deviceBrandFamilies.push(DeviceBrandFamilyDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DeviceBrandFamilyViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceBrandFamilyViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLicensed"] = this.isLicensed;
        if (Array.isArray(this.deviceBrandFamilies)) {
            data["deviceBrandFamilies"] = [];
            for (let item of this.deviceBrandFamilies)
                data["deviceBrandFamilies"].push(item.toJSON());
        }
        return data;
    }

    clone(): DeviceBrandFamilyViewDto {
        const json = this.toJSON();
        let result = new DeviceBrandFamilyViewDto();
        result.init(json);
        return result;
    }
}

export interface IDeviceBrandFamilyViewDto {
    isLicensed: boolean;
    deviceBrandFamilies: DeviceBrandFamilyDto[] | undefined;
}

export enum DiagnosticReportStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class DiagnosticReportDto implements IDiagnosticReportDto {
    subject: string | undefined;
    status: DiagnosticReportStatus;
    effective: moment.Moment;
    conclusion: string | undefined;
    conclusionCode: string | undefined;
    id: number;

    constructor(data?: IDiagnosticReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subject = _data["subject"];
            this.status = _data["status"];
            this.effective = _data["effective"] ? moment(_data["effective"].toString()) : <any>undefined;
            this.conclusion = _data["conclusion"];
            this.conclusionCode = _data["conclusionCode"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DiagnosticReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new DiagnosticReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subject"] = this.subject;
        data["status"] = this.status;
        data["effective"] = this.effective ? this.effective.toISOString() : <any>undefined;
        data["conclusion"] = this.conclusion;
        data["conclusionCode"] = this.conclusionCode;
        data["id"] = this.id;
        return data;
    }

    clone(): DiagnosticReportDto {
        const json = this.toJSON();
        let result = new DiagnosticReportDto();
        result.init(json);
        return result;
    }
}

export interface IDiagnosticReportDto {
    subject: string | undefined;
    status: DiagnosticReportStatus;
    effective: moment.Moment;
    conclusion: string | undefined;
    conclusionCode: string | undefined;
    id: number;
}

export class DocumentFileDto implements IDocumentFileDto {
    filename: string | undefined;
    filepath: string | undefined;
    filetype: string | undefined;
    filelength: number;
    documentType: number;
    enable: boolean;
    active: boolean;
    userId: number;
    dateUploaded: moment.Moment;
    manufacturerId: string | undefined;
    manufacturer: string | undefined;
    specialtyName: string | undefined;
    deviceClassName: string | undefined;
    deviceFamilyName: string | undefined;
    id: number;

    constructor(data?: IDocumentFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.filename = _data["filename"];
            this.filepath = _data["filepath"];
            this.filetype = _data["filetype"];
            this.filelength = _data["filelength"];
            this.documentType = _data["documentType"];
            this.enable = _data["enable"];
            this.active = _data["active"];
            this.userId = _data["userId"];
            this.dateUploaded = _data["dateUploaded"] ? moment(_data["dateUploaded"].toString()) : <any>undefined;
            this.manufacturerId = _data["manufacturerId"];
            this.manufacturer = _data["manufacturer"];
            this.specialtyName = _data["specialtyName"];
            this.deviceClassName = _data["deviceClassName"];
            this.deviceFamilyName = _data["deviceFamilyName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DocumentFileDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentFileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filename"] = this.filename;
        data["filepath"] = this.filepath;
        data["filetype"] = this.filetype;
        data["filelength"] = this.filelength;
        data["documentType"] = this.documentType;
        data["enable"] = this.enable;
        data["active"] = this.active;
        data["userId"] = this.userId;
        data["dateUploaded"] = this.dateUploaded ? this.dateUploaded.toISOString() : <any>undefined;
        data["manufacturerId"] = this.manufacturerId;
        data["manufacturer"] = this.manufacturer;
        data["specialtyName"] = this.specialtyName;
        data["deviceClassName"] = this.deviceClassName;
        data["deviceFamilyName"] = this.deviceFamilyName;
        data["id"] = this.id;
        return data;
    }

    clone(): DocumentFileDto {
        const json = this.toJSON();
        let result = new DocumentFileDto();
        result.init(json);
        return result;
    }
}

export interface IDocumentFileDto {
    filename: string | undefined;
    filepath: string | undefined;
    filetype: string | undefined;
    filelength: number;
    documentType: number;
    enable: boolean;
    active: boolean;
    userId: number;
    dateUploaded: moment.Moment;
    manufacturerId: string | undefined;
    manufacturer: string | undefined;
    specialtyName: string | undefined;
    deviceClassName: string | undefined;
    deviceFamilyName: string | undefined;
    id: number;
}

export class DownloadFileInput implements IDownloadFileInput {
    userId: number;
    documentId: number;

    constructor(data?: IDownloadFileInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.documentId = _data["documentId"];
        }
    }

    static fromJS(data: any): DownloadFileInput {
        data = typeof data === 'object' ? data : {};
        let result = new DownloadFileInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["documentId"] = this.documentId;
        return data;
    }

    clone(): DownloadFileInput {
        const json = this.toJSON();
        let result = new DownloadFileInput();
        result.init(json);
        return result;
    }
}

export interface IDownloadFileInput {
    userId: number;
    documentId: number;
}

export class DownloadFileDto implements IDownloadFileDto {
    fileName: string | undefined;
    fileType: string | undefined;
    fileContent: string | undefined;

    constructor(data?: IDownloadFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileName = _data["fileName"];
            this.fileType = _data["fileType"];
            this.fileContent = _data["fileContent"];
        }
    }

    static fromJS(data: any): DownloadFileDto {
        data = typeof data === 'object' ? data : {};
        let result = new DownloadFileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["fileContent"] = this.fileContent;
        return data;
    }

    clone(): DownloadFileDto {
        const json = this.toJSON();
        let result = new DownloadFileDto();
        result.init(json);
        return result;
    }
}

export interface IDownloadFileDto {
    fileName: string | undefined;
    fileType: string | undefined;
    fileContent: string | undefined;
}

export class FileErrorDto implements IFileErrorDto {
    column: number;
    row: number;
    line: number;
    message: string | undefined;

    constructor(data?: IFileErrorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.column = _data["column"];
            this.row = _data["row"];
            this.line = _data["line"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): FileErrorDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileErrorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["column"] = this.column;
        data["row"] = this.row;
        data["line"] = this.line;
        data["message"] = this.message;
        return data;
    }

    clone(): FileErrorDto {
        const json = this.toJSON();
        let result = new FileErrorDto();
        result.init(json);
        return result;
    }
}

export interface IFileErrorDto {
    column: number;
    row: number;
    line: number;
    message: string | undefined;
}

export class ValidationResponseDto implements IValidationResponseDto {
    numberRows: number;
    hasErrors: boolean;
    errors: FileErrorDto[] | undefined;

    constructor(data?: IValidationResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.numberRows = _data["numberRows"];
            this.hasErrors = _data["hasErrors"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors.push(FileErrorDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ValidationResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["numberRows"] = this.numberRows;
        data["hasErrors"] = this.hasErrors;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        return data;
    }

    clone(): ValidationResponseDto {
        const json = this.toJSON();
        let result = new ValidationResponseDto();
        result.init(json);
        return result;
    }
}

export interface IValidationResponseDto {
    numberRows: number;
    hasErrors: boolean;
    errors: FileErrorDto[] | undefined;
}

export class DocumentFileDtoPagedResultDto implements IDocumentFileDtoPagedResultDto {
    totalCount: number;
    items: DocumentFileDto[] | undefined;

    constructor(data?: IDocumentFileDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(DocumentFileDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DocumentFileDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentFileDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): DocumentFileDtoPagedResultDto {
        const json = this.toJSON();
        let result = new DocumentFileDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IDocumentFileDtoPagedResultDto {
    totalCount: number;
    items: DocumentFileDto[] | undefined;
}

export class EthnicityDto implements IEthnicityDto {
    description: string | undefined;
    id: number;

    constructor(data?: IEthnicityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EthnicityDto {
        data = typeof data === 'object' ? data : {};
        let result = new EthnicityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["id"] = this.id;
        return data;
    }

    clone(): EthnicityDto {
        const json = this.toJSON();
        let result = new EthnicityDto();
        result.init(json);
        return result;
    }
}

export interface IEthnicityDto {
    description: string | undefined;
    id: number;
}

export class UkRegionDto implements IUkRegionDto {
    name: string | undefined;
    isEnabled: boolean;
    id: number;

    constructor(data?: IUkRegionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.isEnabled = _data["isEnabled"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UkRegionDto {
        data = typeof data === 'object' ? data : {};
        let result = new UkRegionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isEnabled"] = this.isEnabled;
        data["id"] = this.id;
        return data;
    }

    clone(): UkRegionDto {
        const json = this.toJSON();
        let result = new UkRegionDto();
        result.init(json);
        return result;
    }
}

export interface IUkRegionDto {
    name: string | undefined;
    isEnabled: boolean;
    id: number;
}

export class IntegratedCareSystemDto implements IIntegratedCareSystemDto {
    name: string | undefined;
    ukRegionId: number;
    ukRegion: UkRegionDto;
    id: number;

    constructor(data?: IIntegratedCareSystemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.ukRegionId = _data["ukRegionId"];
            this.ukRegion = _data["ukRegion"] ? UkRegionDto.fromJS(_data["ukRegion"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): IntegratedCareSystemDto {
        data = typeof data === 'object' ? data : {};
        let result = new IntegratedCareSystemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["ukRegionId"] = this.ukRegionId;
        data["ukRegion"] = this.ukRegion ? this.ukRegion.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): IntegratedCareSystemDto {
        const json = this.toJSON();
        let result = new IntegratedCareSystemDto();
        result.init(json);
        return result;
    }
}

export interface IIntegratedCareSystemDto {
    name: string | undefined;
    ukRegionId: number;
    ukRegion: UkRegionDto;
    id: number;
}

export class RegionManagementDataDto implements IRegionManagementDataDto {
    name: string | undefined;
    avatar: string | undefined;
    dataType: string | undefined;
    parentId: string | undefined;
    trustId: string | undefined;
    postcode: string | undefined;
    trustName: string | undefined;
    regionName: string | undefined;
    countryName: string | undefined;
    icsId: number | undefined;
    groupTrust: string | undefined;
    activeDevMgt: boolean;
    showButtonDevProc: boolean;
    selectedIcs: IntegratedCareSystemDto[] | undefined;

    constructor(data?: IRegionManagementDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.avatar = _data["avatar"];
            this.dataType = _data["dataType"];
            this.parentId = _data["parentId"];
            this.trustId = _data["trustId"];
            this.postcode = _data["postcode"];
            this.trustName = _data["trustName"];
            this.regionName = _data["regionName"];
            this.countryName = _data["countryName"];
            this.icsId = _data["icsId"];
            this.groupTrust = _data["groupTrust"];
            this.activeDevMgt = _data["activeDevMgt"];
            this.showButtonDevProc = _data["showButtonDevProc"];
            if (Array.isArray(_data["selectedIcs"])) {
                this.selectedIcs = [] as any;
                for (let item of _data["selectedIcs"])
                    this.selectedIcs.push(IntegratedCareSystemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RegionManagementDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegionManagementDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["avatar"] = this.avatar;
        data["dataType"] = this.dataType;
        data["parentId"] = this.parentId;
        data["trustId"] = this.trustId;
        data["postcode"] = this.postcode;
        data["trustName"] = this.trustName;
        data["regionName"] = this.regionName;
        data["countryName"] = this.countryName;
        data["icsId"] = this.icsId;
        data["groupTrust"] = this.groupTrust;
        data["activeDevMgt"] = this.activeDevMgt;
        data["showButtonDevProc"] = this.showButtonDevProc;
        if (Array.isArray(this.selectedIcs)) {
            data["selectedIcs"] = [];
            for (let item of this.selectedIcs)
                data["selectedIcs"].push(item.toJSON());
        }
        return data;
    }

    clone(): RegionManagementDataDto {
        const json = this.toJSON();
        let result = new RegionManagementDataDto();
        result.init(json);
        return result;
    }
}

export interface IRegionManagementDataDto {
    name: string | undefined;
    avatar: string | undefined;
    dataType: string | undefined;
    parentId: string | undefined;
    trustId: string | undefined;
    postcode: string | undefined;
    trustName: string | undefined;
    regionName: string | undefined;
    countryName: string | undefined;
    icsId: number | undefined;
    groupTrust: string | undefined;
    activeDevMgt: boolean;
    showButtonDevProc: boolean;
    selectedIcs: IntegratedCareSystemDto[] | undefined;
}

export class RegionManagementNodeDto implements IRegionManagementNodeDto {
    key: string | undefined;
    label: string | undefined;
    type: string | undefined;
    styleClass: string | undefined;
    expanded: boolean;
    icon: string | undefined;
    partialSelected: boolean | undefined;
    selected: boolean | undefined;
    data: RegionManagementDataDto;
    children: RegionManagementNodeDto[] | undefined;

    constructor(data?: IRegionManagementNodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.label = _data["label"];
            this.type = _data["type"];
            this.styleClass = _data["styleClass"];
            this.expanded = _data["expanded"];
            this.icon = _data["icon"];
            this.partialSelected = _data["partialSelected"];
            this.selected = _data["selected"];
            this.data = _data["data"] ? RegionManagementDataDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children.push(RegionManagementNodeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RegionManagementNodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegionManagementNodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["label"] = this.label;
        data["type"] = this.type;
        data["styleClass"] = this.styleClass;
        data["expanded"] = this.expanded;
        data["icon"] = this.icon;
        data["partialSelected"] = this.partialSelected;
        data["selected"] = this.selected;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        return data;
    }

    clone(): RegionManagementNodeDto {
        const json = this.toJSON();
        let result = new RegionManagementNodeDto();
        result.init(json);
        return result;
    }
}

export interface IRegionManagementNodeDto {
    key: string | undefined;
    label: string | undefined;
    type: string | undefined;
    styleClass: string | undefined;
    expanded: boolean;
    icon: string | undefined;
    partialSelected: boolean | undefined;
    selected: boolean | undefined;
    data: RegionManagementDataDto;
    children: RegionManagementNodeDto[] | undefined;
}

export class HospitalDtoPagedResultDto implements IHospitalDtoPagedResultDto {
    totalCount: number;
    items: HospitalDto[] | undefined;

    constructor(data?: IHospitalDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(HospitalDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): HospitalDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new HospitalDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): HospitalDtoPagedResultDto {
        const json = this.toJSON();
        let result = new HospitalDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IHospitalDtoPagedResultDto {
    totalCount: number;
    items: HospitalDto[] | undefined;
}

export class PasswordResetInputDto implements IPasswordResetInputDto {
    id: string;
    newPassword: string;
    newPasswordConfirmation: string;

    constructor(data?: IPasswordResetInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.newPassword = _data["newPassword"];
            this.newPasswordConfirmation = _data["newPasswordConfirmation"];
        }
    }

    static fromJS(data: any): PasswordResetInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PasswordResetInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["newPassword"] = this.newPassword;
        data["newPasswordConfirmation"] = this.newPasswordConfirmation;
        return data;
    }

    clone(): PasswordResetInputDto {
        const json = this.toJSON();
        let result = new PasswordResetInputDto();
        result.init(json);
        return result;
    }
}

export interface IPasswordResetInputDto {
    id: string;
    newPassword: string;
    newPasswordConfirmation: string;
}

export enum GenderType {
    _0 = 0,
    _1 = 1,
    _248152002 = 248152002,
    _248153007 = 248153007,
}

export class PatientDto implements IPatientDto {
    dateOfBirth: moment.Moment | undefined;
    gender: GenderType;
    dobYear: number | undefined;
    name: string | undefined;
    deceased: boolean;
    address: string | undefined;
    ethnicCategory: string | undefined;
    id: string | undefined;

    constructor(data?: IPatientDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dateOfBirth = _data["dateOfBirth"] ? moment(_data["dateOfBirth"].toString()) : <any>undefined;
            this.gender = _data["gender"];
            this.dobYear = _data["dobYear"];
            this.name = _data["name"];
            this.deceased = _data["deceased"];
            this.address = _data["address"];
            this.ethnicCategory = _data["ethnicCategory"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PatientDto {
        data = typeof data === 'object' ? data : {};
        let result = new PatientDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["gender"] = this.gender;
        data["dobYear"] = this.dobYear;
        data["name"] = this.name;
        data["deceased"] = this.deceased;
        data["address"] = this.address;
        data["ethnicCategory"] = this.ethnicCategory;
        data["id"] = this.id;
        return data;
    }

    clone(): PatientDto {
        const json = this.toJSON();
        let result = new PatientDto();
        result.init(json);
        return result;
    }
}

export interface IPatientDto {
    dateOfBirth: moment.Moment | undefined;
    gender: GenderType;
    dobYear: number | undefined;
    name: string | undefined;
    deceased: boolean;
    address: string | undefined;
    ethnicCategory: string | undefined;
    id: string | undefined;
}

export enum StatusType {
    _0 = 0,
    _1 = 1,
}

export class TimeSpan implements ITimeSpan {
    readonly ticks: number;
    readonly days: number;
    readonly hours: number;
    readonly milliseconds: number;
    readonly minutes: number;
    readonly seconds: number;
    readonly totalDays: number;
    readonly totalHours: number;
    readonly totalMilliseconds: number;
    readonly totalMinutes: number;
    readonly totalSeconds: number;

    constructor(data?: ITimeSpan) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).ticks = _data["ticks"];
            (<any>this).days = _data["days"];
            (<any>this).hours = _data["hours"];
            (<any>this).milliseconds = _data["milliseconds"];
            (<any>this).minutes = _data["minutes"];
            (<any>this).seconds = _data["seconds"];
            (<any>this).totalDays = _data["totalDays"];
            (<any>this).totalHours = _data["totalHours"];
            (<any>this).totalMilliseconds = _data["totalMilliseconds"];
            (<any>this).totalMinutes = _data["totalMinutes"];
            (<any>this).totalSeconds = _data["totalSeconds"];
        }
    }

    static fromJS(data: any): TimeSpan {
        data = typeof data === 'object' ? data : {};
        let result = new TimeSpan();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticks"] = this.ticks;
        data["days"] = this.days;
        data["hours"] = this.hours;
        data["milliseconds"] = this.milliseconds;
        data["minutes"] = this.minutes;
        data["seconds"] = this.seconds;
        data["totalDays"] = this.totalDays;
        data["totalHours"] = this.totalHours;
        data["totalMilliseconds"] = this.totalMilliseconds;
        data["totalMinutes"] = this.totalMinutes;
        data["totalSeconds"] = this.totalSeconds;
        return data;
    }

    clone(): TimeSpan {
        const json = this.toJSON();
        let result = new TimeSpan();
        result.init(json);
        return result;
    }
}

export interface ITimeSpan {
    ticks: number;
    days: number;
    hours: number;
    milliseconds: number;
    minutes: number;
    seconds: number;
    totalDays: number;
    totalHours: number;
    totalMilliseconds: number;
    totalMinutes: number;
    totalSeconds: number;
}

export class ProcedureMethodTypeDto implements IProcedureMethodTypeDto {
    description: string | undefined;
    id: string;

    constructor(data?: IProcedureMethodTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ProcedureMethodTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProcedureMethodTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["id"] = this.id;
        return data;
    }

    clone(): ProcedureMethodTypeDto {
        const json = this.toJSON();
        let result = new ProcedureMethodTypeDto();
        result.init(json);
        return result;
    }
}

export interface IProcedureMethodTypeDto {
    description: string | undefined;
    id: string;
}

export class InstrumentPackDto implements IInstrumentPackDto {
    instrumentPackId: string;
    packName: string | undefined;
    packType: number;
    embodiedCarbon: number | undefined;
    specialty: string | undefined;
    company: string | undefined;
    id: number;

    constructor(data?: IInstrumentPackDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.instrumentPackId = _data["instrumentPackId"];
            this.packName = _data["packName"];
            this.packType = _data["packType"];
            this.embodiedCarbon = _data["embodiedCarbon"];
            this.specialty = _data["specialty"];
            this.company = _data["company"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): InstrumentPackDto {
        data = typeof data === 'object' ? data : {};
        let result = new InstrumentPackDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["instrumentPackId"] = this.instrumentPackId;
        data["packName"] = this.packName;
        data["packType"] = this.packType;
        data["embodiedCarbon"] = this.embodiedCarbon;
        data["specialty"] = this.specialty;
        data["company"] = this.company;
        data["id"] = this.id;
        return data;
    }

    clone(): InstrumentPackDto {
        const json = this.toJSON();
        let result = new InstrumentPackDto();
        result.init(json);
        return result;
    }
}

export interface IInstrumentPackDto {
    instrumentPackId: string;
    packName: string | undefined;
    packType: number;
    embodiedCarbon: number | undefined;
    specialty: string | undefined;
    company: string | undefined;
    id: number;
}

export class PoapProcedureDevicesDto implements IPoapProcedureDevicesDto {
    preOperativeAssessmentId: string;
    poapProcedureId: string;
    deviceId: number;
    snomedId: string | undefined;
    userId: number;
    createdDate: moment.Moment;
    modifiedBy: number | undefined;
    modifiedDate: moment.Moment | undefined;
    device: DeviceDto;
    id: number;

    constructor(data?: IPoapProcedureDevicesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.preOperativeAssessmentId = _data["preOperativeAssessmentId"];
            this.poapProcedureId = _data["poapProcedureId"];
            this.deviceId = _data["deviceId"];
            this.snomedId = _data["snomedId"];
            this.userId = _data["userId"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedBy = _data["modifiedBy"];
            this.modifiedDate = _data["modifiedDate"] ? moment(_data["modifiedDate"].toString()) : <any>undefined;
            this.device = _data["device"] ? DeviceDto.fromJS(_data["device"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PoapProcedureDevicesDto {
        data = typeof data === 'object' ? data : {};
        let result = new PoapProcedureDevicesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["preOperativeAssessmentId"] = this.preOperativeAssessmentId;
        data["poapProcedureId"] = this.poapProcedureId;
        data["deviceId"] = this.deviceId;
        data["snomedId"] = this.snomedId;
        data["userId"] = this.userId;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedBy"] = this.modifiedBy;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["device"] = this.device ? this.device.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): PoapProcedureDevicesDto {
        const json = this.toJSON();
        let result = new PoapProcedureDevicesDto();
        result.init(json);
        return result;
    }
}

export interface IPoapProcedureDevicesDto {
    preOperativeAssessmentId: string;
    poapProcedureId: string;
    deviceId: number;
    snomedId: string | undefined;
    userId: number;
    createdDate: moment.Moment;
    modifiedBy: number | undefined;
    modifiedDate: moment.Moment | undefined;
    device: DeviceDto;
    id: number;
}

export class PoapProcedureDto implements IPoapProcedureDto {
    displayOrder: number;
    name: string | undefined;
    procedureSite: string | undefined;
    method: string | undefined;
    meanTime: number;
    standardDeviation: number;
    actualTime: number;
    isRisk: boolean;
    isPatientPreparation: boolean;
    snomedId: string | undefined;
    parentId: string | undefined;
    preOperativeAssessmentId: string;
    clockStartTimestamp: moment.Moment | undefined;
    clockEndTimestamp: moment.Moment | undefined;
    hasSurveyNotes: boolean;
    showButtonDevProc: boolean;
    poapProcedureDevices: PoapProcedureDevicesDto[] | undefined;
    id: string | undefined;

    constructor(data?: IPoapProcedureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayOrder = _data["displayOrder"];
            this.name = _data["name"];
            this.procedureSite = _data["procedureSite"];
            this.method = _data["method"];
            this.meanTime = _data["meanTime"];
            this.standardDeviation = _data["standardDeviation"];
            this.actualTime = _data["actualTime"];
            this.isRisk = _data["isRisk"];
            this.isPatientPreparation = _data["isPatientPreparation"];
            this.snomedId = _data["snomedId"];
            this.parentId = _data["parentId"];
            this.preOperativeAssessmentId = _data["preOperativeAssessmentId"];
            this.clockStartTimestamp = _data["clockStartTimestamp"] ? moment(_data["clockStartTimestamp"].toString()) : <any>undefined;
            this.clockEndTimestamp = _data["clockEndTimestamp"] ? moment(_data["clockEndTimestamp"].toString()) : <any>undefined;
            this.hasSurveyNotes = _data["hasSurveyNotes"];
            this.showButtonDevProc = _data["showButtonDevProc"];
            if (Array.isArray(_data["poapProcedureDevices"])) {
                this.poapProcedureDevices = [] as any;
                for (let item of _data["poapProcedureDevices"])
                    this.poapProcedureDevices.push(PoapProcedureDevicesDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PoapProcedureDto {
        data = typeof data === 'object' ? data : {};
        let result = new PoapProcedureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayOrder"] = this.displayOrder;
        data["name"] = this.name;
        data["procedureSite"] = this.procedureSite;
        data["method"] = this.method;
        data["meanTime"] = this.meanTime;
        data["standardDeviation"] = this.standardDeviation;
        data["actualTime"] = this.actualTime;
        data["isRisk"] = this.isRisk;
        data["isPatientPreparation"] = this.isPatientPreparation;
        data["snomedId"] = this.snomedId;
        data["parentId"] = this.parentId;
        data["preOperativeAssessmentId"] = this.preOperativeAssessmentId;
        data["clockStartTimestamp"] = this.clockStartTimestamp ? this.clockStartTimestamp.toISOString() : <any>undefined;
        data["clockEndTimestamp"] = this.clockEndTimestamp ? this.clockEndTimestamp.toISOString() : <any>undefined;
        data["hasSurveyNotes"] = this.hasSurveyNotes;
        data["showButtonDevProc"] = this.showButtonDevProc;
        if (Array.isArray(this.poapProcedureDevices)) {
            data["poapProcedureDevices"] = [];
            for (let item of this.poapProcedureDevices)
                data["poapProcedureDevices"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }

    clone(): PoapProcedureDto {
        const json = this.toJSON();
        let result = new PoapProcedureDto();
        result.init(json);
        return result;
    }
}

export interface IPoapProcedureDto {
    displayOrder: number;
    name: string | undefined;
    procedureSite: string | undefined;
    method: string | undefined;
    meanTime: number;
    standardDeviation: number;
    actualTime: number;
    isRisk: boolean;
    isPatientPreparation: boolean;
    snomedId: string | undefined;
    parentId: string | undefined;
    preOperativeAssessmentId: string;
    clockStartTimestamp: moment.Moment | undefined;
    clockEndTimestamp: moment.Moment | undefined;
    hasSurveyNotes: boolean;
    showButtonDevProc: boolean;
    poapProcedureDevices: PoapProcedureDevicesDto[] | undefined;
    id: string | undefined;
}

export class PoapRiskDto implements IPoapRiskDto {
    group: string | undefined;
    key: string | undefined;
    value: string | undefined;
    meanTime: number;
    standardDeviation: number;
    preOperativeAssessmentId: string;
    snomedId: string | undefined;
    diagnosticId: number | undefined;
    id: string | undefined;

    constructor(data?: IPoapRiskDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.group = _data["group"];
            this.key = _data["key"];
            this.value = _data["value"];
            this.meanTime = _data["meanTime"];
            this.standardDeviation = _data["standardDeviation"];
            this.preOperativeAssessmentId = _data["preOperativeAssessmentId"];
            this.snomedId = _data["snomedId"];
            this.diagnosticId = _data["diagnosticId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PoapRiskDto {
        data = typeof data === 'object' ? data : {};
        let result = new PoapRiskDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["group"] = this.group;
        data["key"] = this.key;
        data["value"] = this.value;
        data["meanTime"] = this.meanTime;
        data["standardDeviation"] = this.standardDeviation;
        data["preOperativeAssessmentId"] = this.preOperativeAssessmentId;
        data["snomedId"] = this.snomedId;
        data["diagnosticId"] = this.diagnosticId;
        data["id"] = this.id;
        return data;
    }

    clone(): PoapRiskDto {
        const json = this.toJSON();
        let result = new PoapRiskDto();
        result.init(json);
        return result;
    }
}

export interface IPoapRiskDto {
    group: string | undefined;
    key: string | undefined;
    value: string | undefined;
    meanTime: number;
    standardDeviation: number;
    preOperativeAssessmentId: string;
    snomedId: string | undefined;
    diagnosticId: number | undefined;
    id: string | undefined;
}

export class TheaterDto implements ITheaterDto {
    theaterId: string | undefined;
    name: string | undefined;
    hospitalId: string | undefined;
    id: string;

    constructor(data?: ITheaterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.theaterId = _data["theaterId"];
            this.name = _data["name"];
            this.hospitalId = _data["hospitalId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TheaterDto {
        data = typeof data === 'object' ? data : {};
        let result = new TheaterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["theaterId"] = this.theaterId;
        data["name"] = this.name;
        data["hospitalId"] = this.hospitalId;
        data["id"] = this.id;
        return data;
    }

    clone(): TheaterDto {
        const json = this.toJSON();
        let result = new TheaterDto();
        result.init(json);
        return result;
    }
}

export interface ITheaterDto {
    theaterId: string | undefined;
    name: string | undefined;
    hospitalId: string | undefined;
    id: string;
}

export class PreOperativeAssessmentDto implements IPreOperativeAssessmentDto {
    surgeonName: string | undefined;
    surgeonExperience: SurgeonExperienceType;
    anesthetistName: string | undefined;
    dateOfBirthYear: number | undefined;
    gender: GenderType;
    status: StatusType;
    assessmentDate: moment.Moment;
    surgeryDate: moment.Moment;
    theaterId: string;
    methodId: string | undefined;
    hospitalId: string | undefined;
    patientId: string | undefined;
    surgeonId: number;
    bodyStructureId: number;
    totalMeanTime: number;
    ethnicityId: number;
    isSmoker: boolean;
    isSelectAll: boolean;
    isArchived: boolean;
    clockStartTimestamp: TimeSpan;
    clockEndTimeStamp: TimeSpan;
    bodyStructureGroupId: string | undefined;
    timezone: string | undefined;
    procedureMethodTypes: ProcedureMethodTypeDto[] | undefined;
    instrumentPacks: InstrumentPackDto[] | undefined;
    procedures: PoapProcedureDto[] | undefined;
    risks: PoapRiskDto[] | undefined;
    awaitingRiskCompletion: number;
    diagnosticReportId: number | undefined;
    bodyStructure: BodyStructureDto;
    patient: PatientDto;
    surgeon: UserDto;
    hospital: HospitalDto;
    theater: TheaterDto;
    diagnosticReport: DiagnosticReportDto;
    id: string;

    constructor(data?: IPreOperativeAssessmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.surgeonName = _data["surgeonName"];
            this.surgeonExperience = _data["surgeonExperience"];
            this.anesthetistName = _data["anesthetistName"];
            this.dateOfBirthYear = _data["dateOfBirthYear"];
            this.gender = _data["gender"];
            this.status = _data["status"];
            this.assessmentDate = _data["assessmentDate"] ? moment(_data["assessmentDate"].toString()) : <any>undefined;
            this.surgeryDate = _data["surgeryDate"] ? moment(_data["surgeryDate"].toString()) : <any>undefined;
            this.theaterId = _data["theaterId"];
            this.methodId = _data["methodId"];
            this.hospitalId = _data["hospitalId"];
            this.patientId = _data["patientId"];
            this.surgeonId = _data["surgeonId"];
            this.bodyStructureId = _data["bodyStructureId"];
            this.totalMeanTime = _data["totalMeanTime"];
            this.ethnicityId = _data["ethnicityId"];
            this.isSmoker = _data["isSmoker"];
            this.isSelectAll = _data["isSelectAll"];
            this.isArchived = _data["isArchived"];
            this.clockStartTimestamp = _data["clockStartTimestamp"] ? TimeSpan.fromJS(_data["clockStartTimestamp"]) : <any>undefined;
            this.clockEndTimeStamp = _data["clockEndTimeStamp"] ? TimeSpan.fromJS(_data["clockEndTimeStamp"]) : <any>undefined;
            this.bodyStructureGroupId = _data["bodyStructureGroupId"];
            this.timezone = _data["timezone"];
            if (Array.isArray(_data["procedureMethodTypes"])) {
                this.procedureMethodTypes = [] as any;
                for (let item of _data["procedureMethodTypes"])
                    this.procedureMethodTypes.push(ProcedureMethodTypeDto.fromJS(item));
            }
            if (Array.isArray(_data["instrumentPacks"])) {
                this.instrumentPacks = [] as any;
                for (let item of _data["instrumentPacks"])
                    this.instrumentPacks.push(InstrumentPackDto.fromJS(item));
            }
            if (Array.isArray(_data["procedures"])) {
                this.procedures = [] as any;
                for (let item of _data["procedures"])
                    this.procedures.push(PoapProcedureDto.fromJS(item));
            }
            if (Array.isArray(_data["risks"])) {
                this.risks = [] as any;
                for (let item of _data["risks"])
                    this.risks.push(PoapRiskDto.fromJS(item));
            }
            this.awaitingRiskCompletion = _data["awaitingRiskCompletion"];
            this.diagnosticReportId = _data["diagnosticReportId"];
            this.bodyStructure = _data["bodyStructure"] ? BodyStructureDto.fromJS(_data["bodyStructure"]) : <any>undefined;
            this.patient = _data["patient"] ? PatientDto.fromJS(_data["patient"]) : <any>undefined;
            this.surgeon = _data["surgeon"] ? UserDto.fromJS(_data["surgeon"]) : <any>undefined;
            this.hospital = _data["hospital"] ? HospitalDto.fromJS(_data["hospital"]) : <any>undefined;
            this.theater = _data["theater"] ? TheaterDto.fromJS(_data["theater"]) : <any>undefined;
            this.diagnosticReport = _data["diagnosticReport"] ? DiagnosticReportDto.fromJS(_data["diagnosticReport"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PreOperativeAssessmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new PreOperativeAssessmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["surgeonName"] = this.surgeonName;
        data["surgeonExperience"] = this.surgeonExperience;
        data["anesthetistName"] = this.anesthetistName;
        data["dateOfBirthYear"] = this.dateOfBirthYear;
        data["gender"] = this.gender;
        data["status"] = this.status;
        data["assessmentDate"] = this.assessmentDate ? this.assessmentDate.toISOString() : <any>undefined;
        data["surgeryDate"] = this.surgeryDate ? this.surgeryDate.toISOString() : <any>undefined;
        data["theaterId"] = this.theaterId;
        data["methodId"] = this.methodId;
        data["hospitalId"] = this.hospitalId;
        data["patientId"] = this.patientId;
        data["surgeonId"] = this.surgeonId;
        data["bodyStructureId"] = this.bodyStructureId;
        data["totalMeanTime"] = this.totalMeanTime;
        data["ethnicityId"] = this.ethnicityId;
        data["isSmoker"] = this.isSmoker;
        data["isSelectAll"] = this.isSelectAll;
        data["isArchived"] = this.isArchived;
        data["clockStartTimestamp"] = this.clockStartTimestamp ? this.clockStartTimestamp.toJSON() : <any>undefined;
        data["clockEndTimeStamp"] = this.clockEndTimeStamp ? this.clockEndTimeStamp.toJSON() : <any>undefined;
        data["bodyStructureGroupId"] = this.bodyStructureGroupId;
        data["timezone"] = this.timezone;
        if (Array.isArray(this.procedureMethodTypes)) {
            data["procedureMethodTypes"] = [];
            for (let item of this.procedureMethodTypes)
                data["procedureMethodTypes"].push(item.toJSON());
        }
        if (Array.isArray(this.instrumentPacks)) {
            data["instrumentPacks"] = [];
            for (let item of this.instrumentPacks)
                data["instrumentPacks"].push(item.toJSON());
        }
        if (Array.isArray(this.procedures)) {
            data["procedures"] = [];
            for (let item of this.procedures)
                data["procedures"].push(item.toJSON());
        }
        if (Array.isArray(this.risks)) {
            data["risks"] = [];
            for (let item of this.risks)
                data["risks"].push(item.toJSON());
        }
        data["awaitingRiskCompletion"] = this.awaitingRiskCompletion;
        data["diagnosticReportId"] = this.diagnosticReportId;
        data["bodyStructure"] = this.bodyStructure ? this.bodyStructure.toJSON() : <any>undefined;
        data["patient"] = this.patient ? this.patient.toJSON() : <any>undefined;
        data["surgeon"] = this.surgeon ? this.surgeon.toJSON() : <any>undefined;
        data["hospital"] = this.hospital ? this.hospital.toJSON() : <any>undefined;
        data["theater"] = this.theater ? this.theater.toJSON() : <any>undefined;
        data["diagnosticReport"] = this.diagnosticReport ? this.diagnosticReport.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): PreOperativeAssessmentDto {
        const json = this.toJSON();
        let result = new PreOperativeAssessmentDto();
        result.init(json);
        return result;
    }
}

export interface IPreOperativeAssessmentDto {
    surgeonName: string | undefined;
    surgeonExperience: SurgeonExperienceType;
    anesthetistName: string | undefined;
    dateOfBirthYear: number | undefined;
    gender: GenderType;
    status: StatusType;
    assessmentDate: moment.Moment;
    surgeryDate: moment.Moment;
    theaterId: string;
    methodId: string | undefined;
    hospitalId: string | undefined;
    patientId: string | undefined;
    surgeonId: number;
    bodyStructureId: number;
    totalMeanTime: number;
    ethnicityId: number;
    isSmoker: boolean;
    isSelectAll: boolean;
    isArchived: boolean;
    clockStartTimestamp: TimeSpan;
    clockEndTimeStamp: TimeSpan;
    bodyStructureGroupId: string | undefined;
    timezone: string | undefined;
    procedureMethodTypes: ProcedureMethodTypeDto[] | undefined;
    instrumentPacks: InstrumentPackDto[] | undefined;
    procedures: PoapProcedureDto[] | undefined;
    risks: PoapRiskDto[] | undefined;
    awaitingRiskCompletion: number;
    diagnosticReportId: number | undefined;
    bodyStructure: BodyStructureDto;
    patient: PatientDto;
    surgeon: UserDto;
    hospital: HospitalDto;
    theater: TheaterDto;
    diagnosticReport: DiagnosticReportDto;
    id: string;
}

export enum PatientSurveyStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class PatientSurveyNotesDto implements IPatientSurveyNotesDto {
    patientSurveyId: string;
    noteSeries: number;
    noteTabs: number;
    noteDescription: string | undefined;
    preOperativeAssessmentId: string;
    poapProcedureId: string;
    createdDate: moment.Moment;
    createdBy: number;
    updatedDate: moment.Moment | undefined;
    updatedBy: number | undefined;
    patientSurvey: PatientSurveyDto;
    id: string;

    constructor(data?: IPatientSurveyNotesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.patientSurveyId = _data["patientSurveyId"];
            this.noteSeries = _data["noteSeries"];
            this.noteTabs = _data["noteTabs"];
            this.noteDescription = _data["noteDescription"];
            this.preOperativeAssessmentId = _data["preOperativeAssessmentId"];
            this.poapProcedureId = _data["poapProcedureId"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            this.patientSurvey = _data["patientSurvey"] ? PatientSurveyDto.fromJS(_data["patientSurvey"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PatientSurveyNotesDto {
        data = typeof data === 'object' ? data : {};
        let result = new PatientSurveyNotesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["patientSurveyId"] = this.patientSurveyId;
        data["noteSeries"] = this.noteSeries;
        data["noteTabs"] = this.noteTabs;
        data["noteDescription"] = this.noteDescription;
        data["preOperativeAssessmentId"] = this.preOperativeAssessmentId;
        data["poapProcedureId"] = this.poapProcedureId;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        data["patientSurvey"] = this.patientSurvey ? this.patientSurvey.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): PatientSurveyNotesDto {
        const json = this.toJSON();
        let result = new PatientSurveyNotesDto();
        result.init(json);
        return result;
    }
}

export interface IPatientSurveyNotesDto {
    patientSurveyId: string;
    noteSeries: number;
    noteTabs: number;
    noteDescription: string | undefined;
    preOperativeAssessmentId: string;
    poapProcedureId: string;
    createdDate: moment.Moment;
    createdBy: number;
    updatedDate: moment.Moment | undefined;
    updatedBy: number | undefined;
    patientSurvey: PatientSurveyDto;
    id: string;
}

export class PatientSurveyDto implements IPatientSurveyDto {
    patientId: string | undefined;
    hospitalId: string | undefined;
    bodyStructureId: number;
    surgeonId: number;
    preOperativeAssessmentId: string;
    patientDobYear: number | undefined;
    surgeryDate: moment.Moment | undefined;
    endTime: string | undefined;
    nextLocation: string | undefined;
    theaterId: string;
    methodId: string | undefined;
    observerNotes: string | undefined;
    observerStaffId: string | undefined;
    observerSignature: string | undefined;
    totalMeanTime: number;
    weekOfYear: string | undefined;
    startTime: string | undefined;
    dateStart: moment.Moment | undefined;
    bodyStructure: BodyStructureDto;
    surgeon: UserDto;
    hospital: HospitalDto;
    preOperativeAssessment: PreOperativeAssessmentDto;
    theater: TheaterDto;
    isAdmin: boolean;
    isReplicate: boolean;
    status: PatientSurveyStatus;
    patientSurveyNotes: PatientSurveyNotesDto[] | undefined;
    id: string;

    constructor(data?: IPatientSurveyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.patientId = _data["patientId"];
            this.hospitalId = _data["hospitalId"];
            this.bodyStructureId = _data["bodyStructureId"];
            this.surgeonId = _data["surgeonId"];
            this.preOperativeAssessmentId = _data["preOperativeAssessmentId"];
            this.patientDobYear = _data["patientDobYear"];
            this.surgeryDate = _data["surgeryDate"] ? moment(_data["surgeryDate"].toString()) : <any>undefined;
            this.endTime = _data["endTime"];
            this.nextLocation = _data["nextLocation"];
            this.theaterId = _data["theaterId"];
            this.methodId = _data["methodId"];
            this.observerNotes = _data["observerNotes"];
            this.observerStaffId = _data["observerStaffId"];
            this.observerSignature = _data["observerSignature"];
            this.totalMeanTime = _data["totalMeanTime"];
            this.weekOfYear = _data["weekOfYear"];
            this.startTime = _data["startTime"];
            this.dateStart = _data["dateStart"] ? moment(_data["dateStart"].toString()) : <any>undefined;
            this.bodyStructure = _data["bodyStructure"] ? BodyStructureDto.fromJS(_data["bodyStructure"]) : <any>undefined;
            this.surgeon = _data["surgeon"] ? UserDto.fromJS(_data["surgeon"]) : <any>undefined;
            this.hospital = _data["hospital"] ? HospitalDto.fromJS(_data["hospital"]) : <any>undefined;
            this.preOperativeAssessment = _data["preOperativeAssessment"] ? PreOperativeAssessmentDto.fromJS(_data["preOperativeAssessment"]) : <any>undefined;
            this.theater = _data["theater"] ? TheaterDto.fromJS(_data["theater"]) : <any>undefined;
            this.isAdmin = _data["isAdmin"];
            this.isReplicate = _data["isReplicate"];
            this.status = _data["status"];
            if (Array.isArray(_data["patientSurveyNotes"])) {
                this.patientSurveyNotes = [] as any;
                for (let item of _data["patientSurveyNotes"])
                    this.patientSurveyNotes.push(PatientSurveyNotesDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PatientSurveyDto {
        data = typeof data === 'object' ? data : {};
        let result = new PatientSurveyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["patientId"] = this.patientId;
        data["hospitalId"] = this.hospitalId;
        data["bodyStructureId"] = this.bodyStructureId;
        data["surgeonId"] = this.surgeonId;
        data["preOperativeAssessmentId"] = this.preOperativeAssessmentId;
        data["patientDobYear"] = this.patientDobYear;
        data["surgeryDate"] = this.surgeryDate ? this.surgeryDate.toISOString() : <any>undefined;
        data["endTime"] = this.endTime;
        data["nextLocation"] = this.nextLocation;
        data["theaterId"] = this.theaterId;
        data["methodId"] = this.methodId;
        data["observerNotes"] = this.observerNotes;
        data["observerStaffId"] = this.observerStaffId;
        data["observerSignature"] = this.observerSignature;
        data["totalMeanTime"] = this.totalMeanTime;
        data["weekOfYear"] = this.weekOfYear;
        data["startTime"] = this.startTime;
        data["dateStart"] = this.dateStart ? this.dateStart.toISOString() : <any>undefined;
        data["bodyStructure"] = this.bodyStructure ? this.bodyStructure.toJSON() : <any>undefined;
        data["surgeon"] = this.surgeon ? this.surgeon.toJSON() : <any>undefined;
        data["hospital"] = this.hospital ? this.hospital.toJSON() : <any>undefined;
        data["preOperativeAssessment"] = this.preOperativeAssessment ? this.preOperativeAssessment.toJSON() : <any>undefined;
        data["theater"] = this.theater ? this.theater.toJSON() : <any>undefined;
        data["isAdmin"] = this.isAdmin;
        data["isReplicate"] = this.isReplicate;
        data["status"] = this.status;
        if (Array.isArray(this.patientSurveyNotes)) {
            data["patientSurveyNotes"] = [];
            for (let item of this.patientSurveyNotes)
                data["patientSurveyNotes"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }

    clone(): PatientSurveyDto {
        const json = this.toJSON();
        let result = new PatientSurveyDto();
        result.init(json);
        return result;
    }
}

export interface IPatientSurveyDto {
    patientId: string | undefined;
    hospitalId: string | undefined;
    bodyStructureId: number;
    surgeonId: number;
    preOperativeAssessmentId: string;
    patientDobYear: number | undefined;
    surgeryDate: moment.Moment | undefined;
    endTime: string | undefined;
    nextLocation: string | undefined;
    theaterId: string;
    methodId: string | undefined;
    observerNotes: string | undefined;
    observerStaffId: string | undefined;
    observerSignature: string | undefined;
    totalMeanTime: number;
    weekOfYear: string | undefined;
    startTime: string | undefined;
    dateStart: moment.Moment | undefined;
    bodyStructure: BodyStructureDto;
    surgeon: UserDto;
    hospital: HospitalDto;
    preOperativeAssessment: PreOperativeAssessmentDto;
    theater: TheaterDto;
    isAdmin: boolean;
    isReplicate: boolean;
    status: PatientSurveyStatus;
    patientSurveyNotes: PatientSurveyNotesDto[] | undefined;
    id: string;
}

export class PatientSurveyDtoPagedResultDto implements IPatientSurveyDtoPagedResultDto {
    totalCount: number;
    items: PatientSurveyDto[] | undefined;

    constructor(data?: IPatientSurveyDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PatientSurveyDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PatientSurveyDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PatientSurveyDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): PatientSurveyDtoPagedResultDto {
        const json = this.toJSON();
        let result = new PatientSurveyDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IPatientSurveyDtoPagedResultDto {
    totalCount: number;
    items: PatientSurveyDto[] | undefined;
}

export class UserDisplayCompletedSurveySettingDto implements IUserDisplayCompletedSurveySettingDto {
    userId: number;
    displayCompletedSurvey: boolean;
    id: number;

    constructor(data?: IUserDisplayCompletedSurveySettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.displayCompletedSurvey = _data["displayCompletedSurvey"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserDisplayCompletedSurveySettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDisplayCompletedSurveySettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["displayCompletedSurvey"] = this.displayCompletedSurvey;
        data["id"] = this.id;
        return data;
    }

    clone(): UserDisplayCompletedSurveySettingDto {
        const json = this.toJSON();
        let result = new UserDisplayCompletedSurveySettingDto();
        result.init(json);
        return result;
    }
}

export interface IUserDisplayCompletedSurveySettingDto {
    userId: number;
    displayCompletedSurvey: boolean;
    id: number;
}

export class PoapRiskFactorDto implements IPoapRiskFactorDto {
    preoperativeAssessmentId: string;
    diagnosticReportId: number;
    riskId: string;
    preOperativeAssessment: PreOperativeAssessmentDto;
    diagnosticReport: DiagnosticReportDto;
    poapRisk: PoapRiskDto;
    id: number;

    constructor(data?: IPoapRiskFactorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.preoperativeAssessmentId = _data["preoperativeAssessmentId"];
            this.diagnosticReportId = _data["diagnosticReportId"];
            this.riskId = _data["riskId"];
            this.preOperativeAssessment = _data["preOperativeAssessment"] ? PreOperativeAssessmentDto.fromJS(_data["preOperativeAssessment"]) : <any>undefined;
            this.diagnosticReport = _data["diagnosticReport"] ? DiagnosticReportDto.fromJS(_data["diagnosticReport"]) : <any>undefined;
            this.poapRisk = _data["poapRisk"] ? PoapRiskDto.fromJS(_data["poapRisk"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PoapRiskFactorDto {
        data = typeof data === 'object' ? data : {};
        let result = new PoapRiskFactorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["preoperativeAssessmentId"] = this.preoperativeAssessmentId;
        data["diagnosticReportId"] = this.diagnosticReportId;
        data["riskId"] = this.riskId;
        data["preOperativeAssessment"] = this.preOperativeAssessment ? this.preOperativeAssessment.toJSON() : <any>undefined;
        data["diagnosticReport"] = this.diagnosticReport ? this.diagnosticReport.toJSON() : <any>undefined;
        data["poapRisk"] = this.poapRisk ? this.poapRisk.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): PoapRiskFactorDto {
        const json = this.toJSON();
        let result = new PoapRiskFactorDto();
        result.init(json);
        return result;
    }
}

export interface IPoapRiskFactorDto {
    preoperativeAssessmentId: string;
    diagnosticReportId: number;
    riskId: string;
    preOperativeAssessment: PreOperativeAssessmentDto;
    diagnosticReport: DiagnosticReportDto;
    poapRisk: PoapRiskDto;
    id: number;
}

export class PreOperativeAssessmentDtoPagedResultDto implements IPreOperativeAssessmentDtoPagedResultDto {
    totalCount: number;
    items: PreOperativeAssessmentDto[] | undefined;

    constructor(data?: IPreOperativeAssessmentDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PreOperativeAssessmentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PreOperativeAssessmentDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PreOperativeAssessmentDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): PreOperativeAssessmentDtoPagedResultDto {
        const json = this.toJSON();
        let result = new PreOperativeAssessmentDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IPreOperativeAssessmentDtoPagedResultDto {
    totalCount: number;
    items: PreOperativeAssessmentDto[] | undefined;
}

export class DiagnosticRiskFactorsMappingDto implements IDiagnosticRiskFactorsMappingDto {
    diagnosticId: number;
    snomedId: string | undefined;
    label: string | undefined;
    isGroup: boolean;
    group: string | undefined;

    constructor(data?: IDiagnosticRiskFactorsMappingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.diagnosticId = _data["diagnosticId"];
            this.snomedId = _data["snomedId"];
            this.label = _data["label"];
            this.isGroup = _data["isGroup"];
            this.group = _data["group"];
        }
    }

    static fromJS(data: any): DiagnosticRiskFactorsMappingDto {
        data = typeof data === 'object' ? data : {};
        let result = new DiagnosticRiskFactorsMappingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["diagnosticId"] = this.diagnosticId;
        data["snomedId"] = this.snomedId;
        data["label"] = this.label;
        data["isGroup"] = this.isGroup;
        data["group"] = this.group;
        return data;
    }

    clone(): DiagnosticRiskFactorsMappingDto {
        const json = this.toJSON();
        let result = new DiagnosticRiskFactorsMappingDto();
        result.init(json);
        return result;
    }
}

export interface IDiagnosticRiskFactorsMappingDto {
    diagnosticId: number;
    snomedId: string | undefined;
    label: string | undefined;
    isGroup: boolean;
    group: string | undefined;
}

export class SetPoapDataSubProcedureDto implements ISetPoapDataSubProcedureDto {
    subProcedureId: string;
    actualTime: number;

    constructor(data?: ISetPoapDataSubProcedureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subProcedureId = _data["subProcedureId"];
            this.actualTime = _data["actualTime"];
        }
    }

    static fromJS(data: any): SetPoapDataSubProcedureDto {
        data = typeof data === 'object' ? data : {};
        let result = new SetPoapDataSubProcedureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subProcedureId"] = this.subProcedureId;
        data["actualTime"] = this.actualTime;
        return data;
    }

    clone(): SetPoapDataSubProcedureDto {
        const json = this.toJSON();
        let result = new SetPoapDataSubProcedureDto();
        result.init(json);
        return result;
    }
}

export interface ISetPoapDataSubProcedureDto {
    subProcedureId: string;
    actualTime: number;
}

export class SetPoapDataTimingDto implements ISetPoapDataTimingDto {
    poapId: string;
    subProcedures: SetPoapDataSubProcedureDto[] | undefined;

    constructor(data?: ISetPoapDataTimingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.poapId = _data["poapId"];
            if (Array.isArray(_data["subProcedures"])) {
                this.subProcedures = [] as any;
                for (let item of _data["subProcedures"])
                    this.subProcedures.push(SetPoapDataSubProcedureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SetPoapDataTimingDto {
        data = typeof data === 'object' ? data : {};
        let result = new SetPoapDataTimingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["poapId"] = this.poapId;
        if (Array.isArray(this.subProcedures)) {
            data["subProcedures"] = [];
            for (let item of this.subProcedures)
                data["subProcedures"].push(item.toJSON());
        }
        return data;
    }

    clone(): SetPoapDataTimingDto {
        const json = this.toJSON();
        let result = new SetPoapDataTimingDto();
        result.init(json);
        return result;
    }
}

export interface ISetPoapDataTimingDto {
    poapId: string;
    subProcedures: SetPoapDataSubProcedureDto[] | undefined;
}

export class SetPoapDataInputDto implements ISetPoapDataInputDto {
    timings: SetPoapDataTimingDto[] | undefined;

    constructor(data?: ISetPoapDataInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["timings"])) {
                this.timings = [] as any;
                for (let item of _data["timings"])
                    this.timings.push(SetPoapDataTimingDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SetPoapDataInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SetPoapDataInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.timings)) {
            data["timings"] = [];
            for (let item of this.timings)
                data["timings"].push(item.toJSON());
        }
        return data;
    }

    clone(): SetPoapDataInputDto {
        const json = this.toJSON();
        let result = new SetPoapDataInputDto();
        result.init(json);
        return result;
    }
}

export interface ISetPoapDataInputDto {
    timings: SetPoapDataTimingDto[] | undefined;
}

export class SetPoapDataErrorOutputDto implements ISetPoapDataErrorOutputDto {
    poapId: string;
    error: string | undefined;

    constructor(data?: ISetPoapDataErrorOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.poapId = _data["poapId"];
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): SetPoapDataErrorOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SetPoapDataErrorOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["poapId"] = this.poapId;
        data["error"] = this.error;
        return data;
    }

    clone(): SetPoapDataErrorOutputDto {
        const json = this.toJSON();
        let result = new SetPoapDataErrorOutputDto();
        result.init(json);
        return result;
    }
}

export interface ISetPoapDataErrorOutputDto {
    poapId: string;
    error: string | undefined;
}

export class SetPoapDataOutputDto implements ISetPoapDataOutputDto {
    poapRecordsReceived: number;
    poapRecordsFailed: number;
    errors: SetPoapDataErrorOutputDto[] | undefined;

    constructor(data?: ISetPoapDataOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.poapRecordsReceived = _data["poapRecordsReceived"];
            this.poapRecordsFailed = _data["poapRecordsFailed"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors.push(SetPoapDataErrorOutputDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SetPoapDataOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SetPoapDataOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["poapRecordsReceived"] = this.poapRecordsReceived;
        data["poapRecordsFailed"] = this.poapRecordsFailed;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        return data;
    }

    clone(): SetPoapDataOutputDto {
        const json = this.toJSON();
        let result = new SetPoapDataOutputDto();
        result.init(json);
        return result;
    }
}

export interface ISetPoapDataOutputDto {
    poapRecordsReceived: number;
    poapRecordsFailed: number;
    errors: SetPoapDataErrorOutputDto[] | undefined;
}

export class GetPoapDataRiskDto implements IGetPoapDataRiskDto {
    riskGroup: string | undefined;
    riskKey: string | undefined;
    riskValue: string | undefined;
    meanTime: number | undefined;
    standardDeviation: number | undefined;

    constructor(data?: IGetPoapDataRiskDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.riskGroup = _data["riskGroup"];
            this.riskKey = _data["riskKey"];
            this.riskValue = _data["riskValue"];
            this.meanTime = _data["meanTime"];
            this.standardDeviation = _data["standardDeviation"];
        }
    }

    static fromJS(data: any): GetPoapDataRiskDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPoapDataRiskDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["riskGroup"] = this.riskGroup;
        data["riskKey"] = this.riskKey;
        data["riskValue"] = this.riskValue;
        data["meanTime"] = this.meanTime;
        data["standardDeviation"] = this.standardDeviation;
        return data;
    }

    clone(): GetPoapDataRiskDto {
        const json = this.toJSON();
        let result = new GetPoapDataRiskDto();
        result.init(json);
        return result;
    }
}

export interface IGetPoapDataRiskDto {
    riskGroup: string | undefined;
    riskKey: string | undefined;
    riskValue: string | undefined;
    meanTime: number | undefined;
    standardDeviation: number | undefined;
}

export class GetPoapDataProcedureDto implements IGetPoapDataProcedureDto {
    orderId: number;
    procedureId: string;
    snomedId: string | undefined;
    name: string | undefined;
    procedureSite: string | undefined;
    method: string | undefined;
    meanTime: number | undefined;
    standardDeviation: number | undefined;
    isRisk: boolean;

    constructor(data?: IGetPoapDataProcedureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"];
            this.procedureId = _data["procedureId"];
            this.snomedId = _data["snomedId"];
            this.name = _data["name"];
            this.procedureSite = _data["procedureSite"];
            this.method = _data["method"];
            this.meanTime = _data["meanTime"];
            this.standardDeviation = _data["standardDeviation"];
            this.isRisk = _data["isRisk"];
        }
    }

    static fromJS(data: any): GetPoapDataProcedureDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPoapDataProcedureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["procedureId"] = this.procedureId;
        data["snomedId"] = this.snomedId;
        data["name"] = this.name;
        data["procedureSite"] = this.procedureSite;
        data["method"] = this.method;
        data["meanTime"] = this.meanTime;
        data["standardDeviation"] = this.standardDeviation;
        data["isRisk"] = this.isRisk;
        return data;
    }

    clone(): GetPoapDataProcedureDto {
        const json = this.toJSON();
        let result = new GetPoapDataProcedureDto();
        result.init(json);
        return result;
    }
}

export interface IGetPoapDataProcedureDto {
    orderId: number;
    procedureId: string;
    snomedId: string | undefined;
    name: string | undefined;
    procedureSite: string | undefined;
    method: string | undefined;
    meanTime: number | undefined;
    standardDeviation: number | undefined;
    isRisk: boolean;
}

export class GetPoapDataPoapDto implements IGetPoapDataPoapDto {
    poapId: string;
    hospitalId: string | undefined;
    theatreId: string | undefined;
    patientId: string | undefined;
    patientDOBYear: number;
    assessmentDate: moment.Moment;
    surgeryDate: moment.Moment;
    gender: string | undefined;
    anesthetistName: string | undefined;
    ethnicity: string | undefined;
    totalMeanTime: number;
    totalStandardDeviation: number;
    risks: GetPoapDataRiskDto[] | undefined;
    subProcedures: GetPoapDataProcedureDto[] | undefined;

    constructor(data?: IGetPoapDataPoapDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.poapId = _data["poapId"];
            this.hospitalId = _data["hospitalId"];
            this.theatreId = _data["theatreId"];
            this.patientId = _data["patientId"];
            this.patientDOBYear = _data["patientDOBYear"];
            this.assessmentDate = _data["assessmentDate"] ? moment(_data["assessmentDate"].toString()) : <any>undefined;
            this.surgeryDate = _data["surgeryDate"] ? moment(_data["surgeryDate"].toString()) : <any>undefined;
            this.gender = _data["gender"];
            this.anesthetistName = _data["anesthetistName"];
            this.ethnicity = _data["ethnicity"];
            this.totalMeanTime = _data["totalMeanTime"];
            this.totalStandardDeviation = _data["totalStandardDeviation"];
            if (Array.isArray(_data["risks"])) {
                this.risks = [] as any;
                for (let item of _data["risks"])
                    this.risks.push(GetPoapDataRiskDto.fromJS(item));
            }
            if (Array.isArray(_data["subProcedures"])) {
                this.subProcedures = [] as any;
                for (let item of _data["subProcedures"])
                    this.subProcedures.push(GetPoapDataProcedureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetPoapDataPoapDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPoapDataPoapDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["poapId"] = this.poapId;
        data["hospitalId"] = this.hospitalId;
        data["theatreId"] = this.theatreId;
        data["patientId"] = this.patientId;
        data["patientDOBYear"] = this.patientDOBYear;
        data["assessmentDate"] = this.assessmentDate ? this.assessmentDate.toISOString() : <any>undefined;
        data["surgeryDate"] = this.surgeryDate ? this.surgeryDate.toISOString() : <any>undefined;
        data["gender"] = this.gender;
        data["anesthetistName"] = this.anesthetistName;
        data["ethnicity"] = this.ethnicity;
        data["totalMeanTime"] = this.totalMeanTime;
        data["totalStandardDeviation"] = this.totalStandardDeviation;
        if (Array.isArray(this.risks)) {
            data["risks"] = [];
            for (let item of this.risks)
                data["risks"].push(item.toJSON());
        }
        if (Array.isArray(this.subProcedures)) {
            data["subProcedures"] = [];
            for (let item of this.subProcedures)
                data["subProcedures"].push(item.toJSON());
        }
        return data;
    }

    clone(): GetPoapDataPoapDto {
        const json = this.toJSON();
        let result = new GetPoapDataPoapDto();
        result.init(json);
        return result;
    }
}

export interface IGetPoapDataPoapDto {
    poapId: string;
    hospitalId: string | undefined;
    theatreId: string | undefined;
    patientId: string | undefined;
    patientDOBYear: number;
    assessmentDate: moment.Moment;
    surgeryDate: moment.Moment;
    gender: string | undefined;
    anesthetistName: string | undefined;
    ethnicity: string | undefined;
    totalMeanTime: number;
    totalStandardDeviation: number;
    risks: GetPoapDataRiskDto[] | undefined;
    subProcedures: GetPoapDataProcedureDto[] | undefined;
}

export class GetPoapDataOutputDto implements IGetPoapDataOutputDto {
    surgeonId: number;
    surgeonName: string | undefined;
    poap: GetPoapDataPoapDto[] | undefined;

    constructor(data?: IGetPoapDataOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.surgeonId = _data["surgeonId"];
            this.surgeonName = _data["surgeonName"];
            if (Array.isArray(_data["poap"])) {
                this.poap = [] as any;
                for (let item of _data["poap"])
                    this.poap.push(GetPoapDataPoapDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetPoapDataOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPoapDataOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["surgeonId"] = this.surgeonId;
        data["surgeonName"] = this.surgeonName;
        if (Array.isArray(this.poap)) {
            data["poap"] = [];
            for (let item of this.poap)
                data["poap"].push(item.toJSON());
        }
        return data;
    }

    clone(): GetPoapDataOutputDto {
        const json = this.toJSON();
        let result = new GetPoapDataOutputDto();
        result.init(json);
        return result;
    }
}

export interface IGetPoapDataOutputDto {
    surgeonId: number;
    surgeonName: string | undefined;
    poap: GetPoapDataPoapDto[] | undefined;
}

export class RegionHospitalMappingDto implements IRegionHospitalMappingDto {
    hospitalIds: string[] | undefined;
    regionIds: string[] | undefined;
    userId: number;

    constructor(data?: IRegionHospitalMappingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["hospitalIds"])) {
                this.hospitalIds = [] as any;
                for (let item of _data["hospitalIds"])
                    this.hospitalIds.push(item);
            }
            if (Array.isArray(_data["regionIds"])) {
                this.regionIds = [] as any;
                for (let item of _data["regionIds"])
                    this.regionIds.push(item);
            }
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): RegionHospitalMappingDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegionHospitalMappingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.hospitalIds)) {
            data["hospitalIds"] = [];
            for (let item of this.hospitalIds)
                data["hospitalIds"].push(item);
        }
        if (Array.isArray(this.regionIds)) {
            data["regionIds"] = [];
            for (let item of this.regionIds)
                data["regionIds"].push(item);
        }
        data["userId"] = this.userId;
        return data;
    }

    clone(): RegionHospitalMappingDto {
        const json = this.toJSON();
        let result = new RegionHospitalMappingDto();
        result.init(json);
        return result;
    }
}

export interface IRegionHospitalMappingDto {
    hospitalIds: string[] | undefined;
    regionIds: string[] | undefined;
    userId: number;
}

export class CreateRegionDto implements ICreateRegionDto {
    id: string | undefined;
    name: string | undefined;
    type: string | undefined;
    parentId: string | undefined;
    isEnabled: boolean;
    icsIds: number[] | undefined;

    constructor(data?: ICreateRegionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.type = _data["type"];
            this.parentId = _data["parentId"];
            this.isEnabled = _data["isEnabled"];
            if (Array.isArray(_data["icsIds"])) {
                this.icsIds = [] as any;
                for (let item of _data["icsIds"])
                    this.icsIds.push(item);
            }
        }
    }

    static fromJS(data: any): CreateRegionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRegionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["type"] = this.type;
        data["parentId"] = this.parentId;
        data["isEnabled"] = this.isEnabled;
        if (Array.isArray(this.icsIds)) {
            data["icsIds"] = [];
            for (let item of this.icsIds)
                data["icsIds"].push(item);
        }
        return data;
    }

    clone(): CreateRegionDto {
        const json = this.toJSON();
        let result = new CreateRegionDto();
        result.init(json);
        return result;
    }
}

export interface ICreateRegionDto {
    id: string | undefined;
    name: string | undefined;
    type: string | undefined;
    parentId: string | undefined;
    isEnabled: boolean;
    icsIds: number[] | undefined;
}

export class DeleteResponseDto implements IDeleteResponseDto {
    deleted: boolean;
    errorMessage: string | undefined;
    successMessage: string | undefined;

    constructor(data?: IDeleteResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deleted = _data["deleted"];
            this.errorMessage = _data["errorMessage"];
            this.successMessage = _data["successMessage"];
        }
    }

    static fromJS(data: any): DeleteResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deleted"] = this.deleted;
        data["errorMessage"] = this.errorMessage;
        data["successMessage"] = this.successMessage;
        return data;
    }

    clone(): DeleteResponseDto {
        const json = this.toJSON();
        let result = new DeleteResponseDto();
        result.init(json);
        return result;
    }
}

export interface IDeleteResponseDto {
    deleted: boolean;
    errorMessage: string | undefined;
    successMessage: string | undefined;
}

export class CreateRoleDto implements ICreateRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;

    constructor(data?: ICreateRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.normalizedName = _data["normalizedName"];
            this.description = _data["description"];
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions.push(item);
            }
        }
    }

    static fromJS(data: any): CreateRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        return data;
    }

    clone(): CreateRoleDto {
        const json = this.toJSON();
        let result = new CreateRoleDto();
        result.init(json);
        return result;
    }
}

export interface ICreateRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;
}

export class RoleDto implements IRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;
    id: number;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.normalizedName = _data["normalizedName"];
            this.description = _data["description"];
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions.push(item);
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        data["id"] = this.id;
        return data;
    }

    clone(): RoleDto {
        const json = this.toJSON();
        let result = new RoleDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;
    id: number;
}

export class RoleListDto implements IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
    creationTime: moment.Moment;
    id: number;

    constructor(data?: IRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isStatic = _data["isStatic"];
            this.isDefault = _data["isDefault"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): RoleListDto {
        const json = this.toJSON();
        let result = new RoleListDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
    creationTime: moment.Moment;
    id: number;
}

export class RoleListDtoListResultDto implements IRoleListDtoListResultDto {
    items: RoleListDto[] | undefined;

    constructor(data?: IRoleListDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleListDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): RoleListDtoListResultDto {
        const json = this.toJSON();
        let result = new RoleListDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDtoListResultDto {
    items: RoleListDto[] | undefined;
}

export class PermissionDto implements IPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    id: number;

    constructor(data?: IPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["id"] = this.id;
        return data;
    }

    clone(): PermissionDto {
        const json = this.toJSON();
        let result = new PermissionDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    id: number;
}

export class PermissionDtoListResultDto implements IPermissionDtoListResultDto {
    items: PermissionDto[] | undefined;

    constructor(data?: IPermissionDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PermissionDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): PermissionDtoListResultDto {
        const json = this.toJSON();
        let result = new PermissionDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDtoListResultDto {
    items: PermissionDto[] | undefined;
}

export class RoleEditDto implements IRoleEditDto {
    name: string;
    displayName: string;
    description: string | undefined;
    isStatic: boolean;
    id: number;

    constructor(data?: IRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isStatic = _data["isStatic"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isStatic"] = this.isStatic;
        data["id"] = this.id;
        return data;
    }

    clone(): RoleEditDto {
        const json = this.toJSON();
        let result = new RoleEditDto();
        result.init(json);
        return result;
    }
}

export interface IRoleEditDto {
    name: string;
    displayName: string;
    description: string | undefined;
    isStatic: boolean;
    id: number;
}

export class FlatPermissionDto implements IFlatPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;

    constructor(data?: IFlatPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): FlatPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        return data;
    }

    clone(): FlatPermissionDto {
        const json = this.toJSON();
        let result = new FlatPermissionDto();
        result.init(json);
        return result;
    }
}

export interface IFlatPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
    role: RoleEditDto;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;

    constructor(data?: IGetRoleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.role = _data["role"] ? RoleEditDto.fromJS(_data["role"]) : <any>undefined;
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions.push(FlatPermissionDto.fromJS(item));
            }
            if (Array.isArray(_data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of _data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): GetRoleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data;
    }

    clone(): GetRoleForEditOutput {
        const json = this.toJSON();
        let result = new GetRoleForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetRoleForEditOutput {
    role: RoleEditDto;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class RoleDtoPagedResultDto implements IRoleDtoPagedResultDto {
    totalCount: number;
    items: RoleDto[] | undefined;

    constructor(data?: IRoleDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): RoleDtoPagedResultDto {
        const json = this.toJSON();
        let result = new RoleDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDtoPagedResultDto {
    totalCount: number;
    items: RoleDto[] | undefined;
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment;
    features: { [key: string]: boolean; } | undefined;

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"];
            this.releaseDate = _data["releaseDate"] ? moment(_data["releaseDate"].toString()) : <any>undefined;
            if (_data["features"]) {
                this.features = {} as any;
                for (let key in _data["features"]) {
                    if (_data["features"].hasOwnProperty(key))
                        (<any>this.features)[key] = _data["features"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    (<any>data["features"])[key] = this.features[key];
            }
        }
        return data;
    }

    clone(): ApplicationInfoDto {
        const json = this.toJSON();
        let result = new ApplicationInfoDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment;
    features: { [key: string]: boolean; } | undefined;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    displayCompletedSurvey: boolean;
    isAdmin: boolean;
    roleNames: string[] | undefined;
    manufactureId: string | undefined;
    id: number;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.displayCompletedSurvey = _data["displayCompletedSurvey"];
            this.isAdmin = _data["isAdmin"];
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames.push(item);
            }
            this.manufactureId = _data["manufactureId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["displayCompletedSurvey"] = this.displayCompletedSurvey;
        data["isAdmin"] = this.isAdmin;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["manufactureId"] = this.manufactureId;
        data["id"] = this.id;
        return data;
    }

    clone(): UserLoginInfoDto {
        const json = this.toJSON();
        let result = new UserLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    displayCompletedSurvey: boolean;
    isAdmin: boolean;
    roleNames: string[] | undefined;
    manufactureId: string | undefined;
    id: number;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    id: number;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["id"] = this.id;
        return data;
    }

    clone(): TenantLoginInfoDto {
        const json = this.toJSON();
        let result = new TenantLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    id: number;
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto;
    user: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.application = _data["application"] ? ApplicationInfoDto.fromJS(_data["application"]) : <any>undefined;
            this.user = _data["user"] ? UserLoginInfoDto.fromJS(_data["user"]) : <any>undefined;
            this.tenant = _data["tenant"] ? TenantLoginInfoDto.fromJS(_data["tenant"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        return data;
    }

    clone(): GetCurrentLoginInformationsOutput {
        const json = this.toJSON();
        let result = new GetCurrentLoginInformationsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto;
    user: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;
}

export class SurveyTimestampSettingDto implements ISurveyTimestampSettingDto {
    id: number;
    hospitalId: string | undefined;
    hospitalName: string | undefined;
    isEnabled: boolean;
    hospital: HospitalDto;

    constructor(data?: ISurveyTimestampSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.hospitalId = _data["hospitalId"];
            this.hospitalName = _data["hospitalName"];
            this.isEnabled = _data["isEnabled"];
            this.hospital = _data["hospital"] ? HospitalDto.fromJS(_data["hospital"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SurveyTimestampSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new SurveyTimestampSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["hospitalId"] = this.hospitalId;
        data["hospitalName"] = this.hospitalName;
        data["isEnabled"] = this.isEnabled;
        data["hospital"] = this.hospital ? this.hospital.toJSON() : <any>undefined;
        return data;
    }

    clone(): SurveyTimestampSettingDto {
        const json = this.toJSON();
        let result = new SurveyTimestampSettingDto();
        result.init(json);
        return result;
    }
}

export interface ISurveyTimestampSettingDto {
    id: number;
    hospitalId: string | undefined;
    hospitalName: string | undefined;
    isEnabled: boolean;
    hospital: HospitalDto;
}

export class CreateTenantDto implements ICreateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    connectionString: string | undefined;
    isActive: boolean;

    constructor(data?: ICreateTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.adminEmailAddress = _data["adminEmailAddress"];
            this.connectionString = _data["connectionString"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["connectionString"] = this.connectionString;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): CreateTenantDto {
        const json = this.toJSON();
        let result = new CreateTenantDto();
        result.init(json);
        return result;
    }
}

export interface ICreateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    connectionString: string | undefined;
    isActive: boolean;
}

export class TenantDto implements ITenantDto {
    tenancyName: string;
    name: string;
    isActive: boolean;
    id: number;

    constructor(data?: ITenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data;
    }

    clone(): TenantDto {
        const json = this.toJSON();
        let result = new TenantDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDto {
    tenancyName: string;
    name: string;
    isActive: boolean;
    id: number;
}

export class TenantDtoPagedResultDto implements ITenantDtoPagedResultDto {
    totalCount: number;
    items: TenantDto[] | undefined;

    constructor(data?: ITenantDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(TenantDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TenantDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): TenantDtoPagedResultDto {
        const json = this.toJSON();
        let result = new TenantDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDtoPagedResultDto {
    totalCount: number;
    items: TenantDto[] | undefined;
}

export class SearchTheaterDto implements ISearchTheaterDto {
    id: string;
    description: string | undefined;

    constructor(data?: ISearchTheaterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): SearchTheaterDto {
        data = typeof data === 'object' ? data : {};
        let result = new SearchTheaterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        return data;
    }

    clone(): SearchTheaterDto {
        const json = this.toJSON();
        let result = new SearchTheaterDto();
        result.init(json);
        return result;
    }
}

export interface ISearchTheaterDto {
    id: string;
    description: string | undefined;
}

export class OutputDto implements IOutputDto {
    isSuccess: boolean;
    isError: boolean;
    errorMessage: string | undefined;

    constructor(data?: IOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.isError = _data["isError"];
            this.errorMessage = _data["errorMessage"];
        }
    }

    static fromJS(data: any): OutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new OutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["isError"] = this.isError;
        data["errorMessage"] = this.errorMessage;
        return data;
    }

    clone(): OutputDto {
        const json = this.toJSON();
        let result = new OutputDto();
        result.init(json);
        return result;
    }
}

export interface IOutputDto {
    isSuccess: boolean;
    isError: boolean;
    errorMessage: string | undefined;
}

export class TheaterDtoPagedResultDto implements ITheaterDtoPagedResultDto {
    totalCount: number;
    items: TheaterDto[] | undefined;

    constructor(data?: ITheaterDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(TheaterDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TheaterDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TheaterDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): TheaterDtoPagedResultDto {
        const json = this.toJSON();
        let result = new TheaterDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ITheaterDtoPagedResultDto {
    totalCount: number;
    items: TheaterDto[] | undefined;
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userNameOrEmailAddress = _data["userNameOrEmailAddress"];
            this.password = _data["password"];
            this.rememberClient = _data["rememberClient"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["rememberClient"] = this.rememberClient;
        return data;
    }

    clone(): AuthenticateModel {
        const json = this.toJSON();
        let result = new AuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["userId"] = this.userId;
        return data;
    }

    clone(): AuthenticateResultModel {
        const json = this.toJSON();
        let result = new AuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;

    constructor(data?: IExternalLoginProviderInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.clientId = _data["clientId"];
        }
    }

    static fromJS(data: any): ExternalLoginProviderInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["clientId"] = this.clientId;
        return data;
    }

    clone(): ExternalLoginProviderInfoModel {
        const json = this.toJSON();
        let result = new ExternalLoginProviderInfoModel();
        result.init(json);
        return result;
    }
}

export interface IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;

    constructor(data?: IExternalAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.authProvider = _data["authProvider"];
            this.providerKey = _data["providerKey"];
            this.providerAccessCode = _data["providerAccessCode"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authProvider"] = this.authProvider;
        data["providerKey"] = this.providerKey;
        data["providerAccessCode"] = this.providerAccessCode;
        return data;
    }

    clone(): ExternalAuthenticateModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    waitingForActivation: boolean;

    constructor(data?: IExternalAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.waitingForActivation = _data["waitingForActivation"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["waitingForActivation"] = this.waitingForActivation;
        return data;
    }

    clone(): ExternalAuthenticateResultModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    waitingForActivation: boolean;
}

export class TrustIcsMappingDto implements ITrustIcsMappingDto {
    regionId: string | undefined;
    integratedCareSystemId: number;
    region: RegionDto;
    integratedCareSystem: IntegratedCareSystemDto;
    id: string;

    constructor(data?: ITrustIcsMappingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.regionId = _data["regionId"];
            this.integratedCareSystemId = _data["integratedCareSystemId"];
            this.region = _data["region"] ? RegionDto.fromJS(_data["region"]) : <any>undefined;
            this.integratedCareSystem = _data["integratedCareSystem"] ? IntegratedCareSystemDto.fromJS(_data["integratedCareSystem"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TrustIcsMappingDto {
        data = typeof data === 'object' ? data : {};
        let result = new TrustIcsMappingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["regionId"] = this.regionId;
        data["integratedCareSystemId"] = this.integratedCareSystemId;
        data["region"] = this.region ? this.region.toJSON() : <any>undefined;
        data["integratedCareSystem"] = this.integratedCareSystem ? this.integratedCareSystem.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): TrustIcsMappingDto {
        const json = this.toJSON();
        let result = new TrustIcsMappingDto();
        result.init(json);
        return result;
    }
}

export interface ITrustIcsMappingDto {
    regionId: string | undefined;
    integratedCareSystemId: number;
    region: RegionDto;
    integratedCareSystem: IntegratedCareSystemDto;
    id: string;
}

export class TrustsDto implements ITrustsDto {
    trustId: number | undefined;
    regionId: string | undefined;
    regionName: string | undefined;
    groupTrust: string | undefined;
    type: string | undefined;
    parentId: string | undefined;
    isEnabled: boolean;

    constructor(data?: ITrustsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trustId = _data["trustId"];
            this.regionId = _data["regionId"];
            this.regionName = _data["regionName"];
            this.groupTrust = _data["groupTrust"];
            this.type = _data["type"];
            this.parentId = _data["parentId"];
            this.isEnabled = _data["isEnabled"];
        }
    }

    static fromJS(data: any): TrustsDto {
        data = typeof data === 'object' ? data : {};
        let result = new TrustsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trustId"] = this.trustId;
        data["regionId"] = this.regionId;
        data["regionName"] = this.regionName;
        data["groupTrust"] = this.groupTrust;
        data["type"] = this.type;
        data["parentId"] = this.parentId;
        data["isEnabled"] = this.isEnabled;
        return data;
    }

    clone(): TrustsDto {
        const json = this.toJSON();
        let result = new TrustsDto();
        result.init(json);
        return result;
    }
}

export interface ITrustsDto {
    trustId: number | undefined;
    regionId: string | undefined;
    regionName: string | undefined;
    groupTrust: string | undefined;
    type: string | undefined;
    parentId: string | undefined;
    isEnabled: boolean;
}

export class CreateUserDto implements ICreateUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    roleNames: string[] | undefined;
    password: string;
    experience: SurgeonExperienceType;
    manufactureId: string | undefined;
    manufactureName: string | undefined;

    constructor(data?: ICreateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames.push(item);
            }
            this.password = _data["password"];
            this.experience = _data["experience"];
            this.manufactureId = _data["manufactureId"];
            this.manufactureName = _data["manufactureName"];
        }
    }

    static fromJS(data: any): CreateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["password"] = this.password;
        data["experience"] = this.experience;
        data["manufactureId"] = this.manufactureId;
        data["manufactureName"] = this.manufactureName;
        return data;
    }

    clone(): CreateUserDto {
        const json = this.toJSON();
        let result = new CreateUserDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    roleNames: string[] | undefined;
    password: string;
    experience: SurgeonExperienceType;
    manufactureId: string | undefined;
    manufactureName: string | undefined;
}

export class RoleDtoListResultDto implements IRoleDtoListResultDto {
    items: RoleDto[] | undefined;

    constructor(data?: IRoleDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): RoleDtoListResultDto {
        const json = this.toJSON();
        let result = new RoleDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDtoListResultDto {
    items: RoleDto[] | undefined;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
    languageName: string;

    constructor(data?: IChangeUserLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.languageName = _data["languageName"];
        }
    }

    static fromJS(data: any): ChangeUserLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        return data;
    }

    clone(): ChangeUserLanguageDto {
        const json = this.toJSON();
        let result = new ChangeUserLanguageDto();
        result.init(json);
        return result;
    }
}

export interface IChangeUserLanguageDto {
    languageName: string;
}

export class ChangePasswordDto implements IChangePasswordDto {
    currentPassword: string;
    newPassword: string;

    constructor(data?: IChangePasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPassword = _data["currentPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data;
    }

    clone(): ChangePasswordDto {
        const json = this.toJSON();
        let result = new ChangePasswordDto();
        result.init(json);
        return result;
    }
}

export interface IChangePasswordDto {
    currentPassword: string;
    newPassword: string;
}

export class ResetPasswordDto implements IResetPasswordDto {
    adminPassword: string;
    userId: number;
    newPassword: string;

    constructor(data?: IResetPasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.adminPassword = _data["adminPassword"];
            this.userId = _data["userId"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adminPassword"] = this.adminPassword;
        data["userId"] = this.userId;
        data["newPassword"] = this.newPassword;
        return data;
    }

    clone(): ResetPasswordDto {
        const json = this.toJSON();
        let result = new ResetPasswordDto();
        result.init(json);
        return result;
    }
}

export interface IResetPasswordDto {
    adminPassword: string;
    userId: number;
    newPassword: string;
}

export class UserDtoPagedResultDto implements IUserDtoPagedResultDto {
    totalCount: number;
    items: UserDto[] | undefined;

    constructor(data?: IUserDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(UserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): UserDtoPagedResultDto {
        const json = this.toJSON();
        let result = new UserDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IUserDtoPagedResultDto {
    totalCount: number;
    items: UserDto[] | undefined;
}

export class UserHospitalDto implements IUserHospitalDto {
    userId: number;
    hospitalId: string | undefined;
    isSelected: boolean;
    hospital: HospitalDto;
    id: string | undefined;

    constructor(data?: IUserHospitalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.hospitalId = _data["hospitalId"];
            this.isSelected = _data["isSelected"];
            this.hospital = _data["hospital"] ? HospitalDto.fromJS(_data["hospital"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserHospitalDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserHospitalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["hospitalId"] = this.hospitalId;
        data["isSelected"] = this.isSelected;
        data["hospital"] = this.hospital ? this.hospital.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): UserHospitalDto {
        const json = this.toJSON();
        let result = new UserHospitalDto();
        result.init(json);
        return result;
    }
}

export interface IUserHospitalDto {
    userId: number;
    hospitalId: string | undefined;
    isSelected: boolean;
    hospital: HospitalDto;
    id: string | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}